# sleigh specification file for ARCv2

define endian=little;
define alignment=2;

# 32-bit Instruction Format (reference page 284 Table 7-3)
# ======================================================================================================
# Name            | Major   |
#                 | Opcode  | 
# ======================================================================================================
# F32_BR0         | 0x00    |  
# F32_BR1         | 0x01    | 
# F32_LD_OFFSET   | 0x02    | 
# F32_ST_OFFSET   | 0x03    | 
# F32_GEN4        | 0x04    | 
# F32_EXT5        | 0x05    | 
# F32_EXT6        | 0x06    | 
# F32_APEX        | 0x07    | 

# 16-bit Instruction Format (reference page 293 Table 7-4)
# ======================================================================================================
# Name            | Major   |
#                 | Opcode  | 
# ======================================================================================================
# F16_COMPACT     | 0x08    |  
# F16_LD_ADD_SUB  | 0x09    | 
# F16_LD_ST_1     | 0x0A    | 
# F16_JLI_EI      | 0x0B    | 
# F16_LD_ADD_RR   | 0x0C    | 
# F16_ADD_IMM     | 0x0D    | 
# F16_OP_HREG     | 0x0E    | 
# F16_GEN_OP      | 0x0F    | 
# F16_LD_WORD     | 0x10    | 
# F16_LD_BYTE     | 0x11    | 
# F16_LD_HALF     | 0x12    | 
# F16_LDX_HALF    | 0x13    | 
# F16_ST_WORD     | 0x14    | 
# F16_ST_BYTE     | 0x15    | 
# F16_ST_HALF     | 0x16    | 
# F16_SH_SUB_BIT  | 0x17    | 
# F16_SP_OPS      | 0x18    | 
# F16_GP_LD_ADD   | 0x19    | 
# F16_PCL_LD      | 0x1A    | 
# F16_MV_IMM      | 0x1B    | 
# F16_OP_IMM      | 0x1C    | 
# F16_BCC_REG     | 0x1D    | 
# F16_BCC         | 0x1E    | 
# F16_BL          | 0x1F    | 


@define F32_BR0         "0b00000"
@define F32_BR1         "0b00001"
@define F32_LD_OFFSET   "0b00010"
@define F32_ST_OFFSET   "0b00011"
@define F32_GEN4        "0b00100"
@define F32_EXT5        "0b00101"
@define F32_EXT6        "0b00110"
@define F32_APEX        "0b00111"

@define F16_COMPACT     "0b01000"
@define F16_LD_ADD_SUB  "0b01001"
@define F16_LD_ST_1     "0b01010"
@define F16_JLI_EI      "0b01011"
@define F16_LD_ADD_RR   "0b01100"
@define F16_ADD_IMM     "0b01101"
@define F16_OP_HREG     "0b01110"
@define F16_GEN_OP      "0b01111"
@define F16_LD_WORD     "0b10000"
@define F16_LD_BYTE     "0b10001"
@define F16_LD_HALF     "0b10010"
@define F16_LDX_HALF    "0b10011"
@define F16_ST_WORD     "0b10100"
@define F16_ST_BYTE     "0b10101"
@define F16_ST_HALF     "0b10110"
@define F16_SH_SUB_BIT  "0b10111"
@define F16_SP_OPS      "0b11000"
@define F16_GP_LD_ADD   "0b11001"
@define F16_PCL_LD      "0b11010"
@define F16_MV_IMM      "0b11011"
@define F16_OP_IMM      "0b11100"
@define F16_BCC_REG     "0b11101"
@define F16_BCC         "0b11110"
@define F16_BL          "0b11111"

# Define the AUX_REGS_BASE space for table as "RAM space" in order to be able to
# access it by address (instructions ei_s and sr)

define space register       type=register_space size=2;
define space ram            type=ram_space      size=4 default;
define space AUX_REGS_BASE  type=ram_space      size=4;

# 64 32-bit registers:
# * r0...r25 = Basecase Core Registers
# * r26 = Global Pointer - gp
# * r27 = Frame Pointer - fp
# * r28 = Stack Pointer - sp
# * r29 = Interrupt Link 
# * r30 = General purpose register
# * r31 = Branch Link - blink
# * r32...r59 = Extension Core Registers
#   * r58 = Accumulator Low - accl
#   * r59 = Accumulator High - acch
# * r60 = Loop Count Register
# * r61 = reserved Register
# * r62 = Long Immediate Data Indicator Register fake register
# * r63 = Program Counter Long-Word (last two bits are all the time 0b00)
define register offset=0x00 size=4 [
    r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10       r11         r12             r13             r14         r15
    r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 gp        fp          sp              ilink           r30         blink
    r32 r33 r34 r35 r36 r37 r38 r39 r40 r41 r42       r43         r44             r45             r46         r47
    r48 r49 r50 r51 r52 r53 r54 r55 r56 r57 accl      acch    	  r60_lp_count    r61reserved     r62limm     pcl
];

define AUX_REGS_BASE offset=0x00 size=4 [ 
	AUX00             # 0x00
	AUX01             # 0x01 
	LP_START          # 0x02  Loop Start Register
	LP_END            # 0x03  Loop End Register
	IDENTITY          # 0x04  Core Identity Register
	DEBUG             # 0x05  Debug Register
	PC                # 0x06  Program Counter
	AUX07             # 0x07
	AUX08             # 0x08  
	SEC_STAT          # 0x09  Secure Status Register
	STATUS32          # 0x0A  Status Register
	STATUS32_P0       # 0x0B  Status Register Priority 0
	AUX0C             # 0x0C
	AUX_USER_SP       # 0x0D  Saved User Stack Pointer
	AUX_IRQ_CTRL      # 0x0E  Interrupt Context Saving Control Register
	DEBUGI            # 0x0F  Interrupt and Register Bank Debug Register
	IC_IVC            # 0x10  Invalid Instruction Cache
	IC_CTRL           # 0x11  Instruction Cache Control Register
	AUX12             # 0x12  
	IC_LIL            # 0x13  Lock Instruction Cache Line
	AUX14             # 0x14
	AUX15             # 0x15
	AUX16             # 0x16
	AUX17             # 0x17
	AUX_DCCM          # 0x18  DCCM Base Address
	IC_IVIL           # 0x19  Invalidate Instruction Cache Line
	IC_RAM_ADDR       # 0x1A  Instruction Cache External-Access Address
	IC_TAG            # 0x1B  Instruction-Cache Tag Access
	IC_XTAG           # 0x1C  Instruction Cache Secure Bit Tag Register 
	IC_DATA           # 0x1D  Instruction Cache Data Access
	AUX1E             # 0x1E
	AUX1F             # 0x1F
	AUX20             # 0x20
	COUNT0            # 0x21  Timer 0 Count Register
	CONTROL0          # 0x22  Timer 0 Control Register
	LIMIT0            # 0x23  Timer 0 Limit Register
	AUX24             # 0x24
	INT_VECTOR_BASE   # 0x25  Interrupt Vector Base Register 
	INT_VECTOR_BASE_S # 0x26  Secure Interrupt Vector Base Register 
	AUX27             # 0x27
	AUX28             # 0x28
	AUX29             # 0x29
	AUX2A             # 0x2A
	AUX2B             # 0x2B
	AUX2C             # 0x2C
	AUX2D             # 0x2D
	AUX2E             # 0x2E
	AUX2F             # 0x2F
	ACG_CTRL          # 0x30  Architectural Clock Gating Control Register
	AUX31             # 0x31
	AUX32             # 0x32
	AUX33             # 0x33
	AUX34             # 0x34
	AUX35             # 0x35
	AUX36             # 0x36
	AUX37             # 0x37
	AUX_KERNEL_SP     # 0x38  Saved Normal Kernel Stack Pointer
	AUX_SEC_U_SP      # 0x39  Saved Secure User Stack Pointer
	AUX_SEC_K_SP      # 0x3A  Saved Secure Kernel Stack Pointer
	AUX_NSEC_SP       # 0x3B  Saved Shadow Normal Stack Pointer
	AUX3C             # 0x3C
	AUX3D             # 0x3D
	AUX3E             # 0x3E
	ERP_CTRL          # 0x3F  Error Protection Hardware Control Register
	AUX40             # 0x40  Register File Error Protection Status Register, RFERP_STATUS_0
	AUX41             # 0x41  Register File Error Protection Status Register, RFERP_STATUS_1
	AUX42             # 0x42
	AUX43             # 0x43  Active Interrupts Register, AUX_IRQ_ACT
	AUX44             # 0x44
	AUX45             # 0x45
	AUX46             # 0x46
	DC_IVDC           # 0x47  Invalidate Data Cache
	DC_CTRL           # 0x48  Data Cache Control Register
	DC_LDL            # 0x49  Lock Data Cache Line
	DC_IVDL           # 0x4A  Invalidate Data Line
	DC_FLSH           # 0x4B  Flush Data Cache
	DC_FLDL           # 0x4C  Flush Data Line
	AUX4D             # 0x4D
	AUX4E             # 0x4E
	AUX4F             # 0x4F
	AUX50             # 0x50
	AUX51             # 0x51
	AUX52             # 0x52
	AUX53             # 0x53
	AUX54             # 0x54
	AUX55             # 0x55
	AUX56             # 0x56
	AUX57             # 0x57
	DC_RAM_ADDR       # 0x58  Data Cache External Access Address
	DC_TAG            # 0x59  Data Cache Tag Access
	DC_XTAG           # 0x5A  Data Cache Secure Bit Register 
	DC_DATA           # 0x5B  Data Cache Data Access
	AUX5C             # 0x5C
	AUX_CACHE_LIMIT   # 0x5D  Non-cached Memory Region 
	AUX5E             # 0x5E
	AUX5F             # 0x5F
	BCR_VER           # 0x60  Build Configuration Registers Version
	AUX61             # 0x61
	AUX62             # 0x62
	BTA_LINK_BUILD    # 0x63  BTA Configuration Register
	AUX64             # 0x64
	AUX65             # 0x65
	AUX66             # 0x66
	AUX67             # 0x67
	VECBASE_AC_BUILD  # 0x68  Interrupt Vector Base Address Configuration
	AUX69             # 0x69
	AUX6A             # 0x6A
	AUX6B             # 0x6B
	AUX6C             # 0x6C
	MPU_BUILD         # 0x6D  Memory Protection Build Configuration Register
	RF_BUILD          # 0x6E  Core Register File Configuration Register
	AUX6F             # 0x6F
	SEC_VECBASE_BUILD # 0x70  Secure Interrupt Vector Base Address Configuration
	AUX71             # 0x71
	D_CACHE_BUILD     # 0x72  Data Cache Configuration Register
	AUX73             # 0x73
	DCCM_BUILD        # 0x74  DCCM Configuration Register
	TIMER_BUILD       # 0x75  Timers Configuration Register
	AP_BUILD          # 0x76  Actionpoints Configuration Register
	I_CACHE_BUILD     # 0x77  Instruction Cache Configuration Register
	ICCM_BUILD        # 0x78  ICCM Configuration Register
	XY_BUILD          # 0x79  XY Build Configuration Register
	AUX7A             # 0x7A
	MULTIPLY_BUILD    # 0x7B  Multiplier Configuration Register
	SWAP_BUILD        # 0x7C  Swap Instruction Configuration Register
	NORM_BUILD        # 0x7D  Normalize Instruction Configuration Register
	MINMAX_BUILD      # 0x7E  Min/Max Instruction Configuration Register
	BARREL_BUILD      # 0x7F  Barrel Shifter Configuration Register
];


#Register with ID 0xC0 (0xC0 * 4 = 0x300)
define AUX_REGS_BASE offset=0x300 size=4 [ 
	AUXC0                 # 0xC0
	ISA_CONFIG            # 0xC1  Instruction Set Configuration Register
	AUXC2                 # 0xC2
	AUXC3                 # 0xC3
	AUXC4                 # 0xC4
	STACK_REGION_BUILD    # 0xC5  Stack Region Configuration Register 
	AUXC6                 # 0xC6
	ERP_BUILD             # 0xC7  Error Protection Configuration Register 
	FPU_BUILD             # 0xC8  Floating-Point Unit Build Register
	CPROT_BUILD           # 0xC9  Code Protection Register
	AUXCA                 # 0xCA
	BS_BUILD              # 0xCB  Bitstream Identity Register
	AGU_BUILD             # 0xCC  AGU Build Configuration Register
	DMAC_BUILD            # 0xCD  DMA Build Configuration Register
	AUXCE                 # 0xCE
	AUXCF                 # 0xCF
	CONNECT_SYSTEM_BUILD  # 0xD0  ARConnect Build Configuration Register
	CONNECT_SEMA_BUILD    # 0xD1  Inter-core Semaphore Unit Build Configuration Register
	CONNECT_MESSAGE_BUILD # 0xD2  Inter-core Message Unit Build Configuration Register
	CONNECT_PMU_BUILD     # 0xD3  Power Management Unit Build Configuration Register
	AUXD4                 # 0xD4
	AUXD5                 # 0xD5
	CONNECT_GFRC_BUILD    # 0xD6  ARConnect Global Free Running Counter Build Configuration Register
	AUXD7                 # 0xD7
	KEY_STORE_BUILD       # 0xD8  Key Store Build Configuration Register
	CAL_STORE_BUILD       # 0xD9  Calibration Parameter Store Build Configuration Register
	AUXDA                 # 0xDA
	SEC_BUILD             # 0xDB  Secure Build Configuration Register
	AUXDC                 # 0xDC
	AUXDD                 # 0xDD
	AUXDE                 # 0xDE
	AUXDF                 # 0xDF
	CONNECT_ICI_BUILD     # 0xE0  Inter-Core Interrupt Unit Build Configuration Register
	CONNECT_ICD_BUILD     # 0xE1  Inter-Core Debug Unit Build Configuration Register 
	AUXE2                 # 0xE2
	CONNECT_PDM_BUILD     # 0xE3  ARConnect Power Domain Management Build Configuration Register
	AUXE4                 # 0xE4
	AUXE5                 # 0xE5
	AUXE6                 # 0xE6
	AUXE7                 # 0xE7
	AUXE8                 # 0xE8
	AUXE9                 # 0xE9
	AUXEA                 # 0xEA
	AUXEB                 # 0xEB
	AUXEC                 # 0xEC
	AUXED                 # 0xED
	AUXEE                 # 0xEE
	LSC_BUILD_AUX         # 0xEF  Lockstep Configuration Register
	AUXF0                 # 0xF0
	ARCH_CONFIG           # 0xF1  Core Architecture Build Configuration Register
	RTT_BUILD             # 0xF2  ARC RTT Build Configuration Register
	IRQ_BUILD             # 0xF3  Interrupt Build Configuration Register
	AUXF4                 # 0xF4
	PCT_BUILD             # 0xF5  Performance Counter Build-Configuration Register
	CC_BUILD              # 0xF6  Countable Conditions Build Configuration Register
	PDM_DVFS_BUILD        # 0xF7  Power Domain Management and DVFS Build Configuration Register
	AUXF8                 # 0xF8  ARCv2 ISA Profile Register, ISA_PROFILE
	MICRO_ARCH_BUILD      # 0xF9  Micro Architecture Configuration Register
	AUXFA                 # 0xFA
	AUXFB                 # 0xFB
	AUXFC                 # 0xFC
	AUXFD                 # 0xFD
	IFQUEUE_BUILD         # 0xFE  Instruction Fetch Queue Configuration Register
	SMART_BUILD           # 0xFF  SMART_BUILD Configuration Register
	COUNT1                # 0x100 Timer 1 Count Register
	CONTROL1              # 0x101 Timer 1 Control Register
	LIMIT1                # 0x102 Timer 1 Limit Register
	AUX_RTC_CTRL          # 0x103 RTC Control Register
	AUX_RTC_LOW           # 0x104 RTC Count Low Register
	AUX_RTC_HIGH          # 0x105 RTC Count High Register
	AUX_ST0_COUNT         # 0x106 Secure Timer 0 Count Register
	AUX_ST0_CTRL          # 0x107 Secure Timer 0 Control Register
	AUX_ST0_LIMIT         # 0x108 Secure Timer 0 Limit Register
	AUX_ST1_COUNT         # 0x109 Secure Timer 1 Count Register
	AUX_ST1_CTRL          # 0x10A Secure Timer 1 Control Register
	AUX_ST1_LIMIT         # 0x10B Secure Timer 1 Limit Register
	AUX10C                # 0x10C
	AUX10D                # 0x10D
	AUX10E                # 0x10E
	AUX10F                # 0x10F
];

#Register with ID 0x200 (0x200 * 4 = 0x800)
define AUX_REGS_BASE offset=0x800 size=4 [ 
	IRQ_PRIORITY_PENDING  # 0x200 Interrupt Priority Pending Register
	AUX_IRQ_HINT          # 0x201 Software Interrupt Trigger
	AUX202                # 0x202
	AUX203                # 0x203
	AUX204                # 0x204
	AUX205                # 0x205
	IRQ_PRIORITY          # 0x206 Interrupt Priority Register
	AUX208                # 0x207
	AUX_ICCM              # 0x208 ICCM base address 
	AUX209                # 0x209
	DMP_PER_AUX           # 0x20A Peripheral Memory Region 
];

#Register with ID 0x220 (0x220 * 4 = 0x880)
define AUX_REGS_BASE offset=0x880 size=4 [ 
	AP_AMV0               # 0x220 Actionpoint Match Value
	AP_AMM0               # 0x221 Actionpoint Match Mask
	AP_AC0                # 0x222 Actionpoint Control
	AP_AMV1               # 0x223 Actionpoint Match Value
	AP_AMM1               # 0x224 Actionpoint Match Mask
	AP_AC1                # 0x225 Actionpoint Control
	AP_AMV2               # 0x226 Actionpoint Match Value
	AP_AMM2               # 0x227 Actionpoint Match Mask
	AP_AC2                # 0x228 Actionpoint Control
	AP_AMV3               # 0x229 Actionpoint Match Value
	AP_AMM3               # 0x22A Actionpoint Match Mask
	AP_AC3                # 0x22B Actionpoint Control
	AP_AMV4               # 0x22C Actionpoint Match Value
	AP_AMM4               # 0x22D Actionpoint Match Mask
	AP_AC4                # 0x22E Actionpoint Control
	AP_AMV5               # 0x22F Actionpoint Match Value
	AP_AMM5               # 0x230 Actionpoint Match Mask
	AP_AC5                # 0x231 Actionpoint Control
	AP_AMV6               # 0x232 Actionpoint Match Value
	AP_AMM6               # 0x233 Actionpoint Match Mask
	AP_AC6                # 0x234 Actionpoint Control
	AP_AMV7               # 0x235 Actionpoint Match Value
	AP_AMM7               # 0x236 Actionpoint Match Mask
	AP_AC7                # 0x237 Actionpoint Control
	WDT_PASSWD            # 0x238 Watchdog Password Register
	WDT_CTRL              # 0x239 Watchdog Timer Register
	WDT_PERIOD            # 0x23A Watchdog Timer Period Register
	WDT_COUNT             # 0x23B Watchdog Timer Count Register
	AUX23C                # 0x23C
	AUX23D                # 0x23D
	AUX23E                # 0x23E
	AP_WP_PC              # 0x23F Watchpoint Program Counter
	CC_INDEX              # 0x240 Countable Conditions Index Register
	CC_NAME0              # 0x241 Countable Conditions Name0 Register
	CC_NAME1              # 0x242 Countable Conditions Name1 Register
];

define AUX_REGS_BASE offset=0x940 size=4 [ 
	PCT_COUNTL            # 0x250 Count-Value Registers
	PCT_COUNTH            # 0x251 Count-Value Registers
	PCT_SNAPL             # 0x252 Snapshot-Value Registers
	PCT_SNAPH             # 0x253 Snapshot-Value Registers
	PCT_CONFIG            # 0x254 Configuration Register
	PCT_CONTROL           # 0x255 Control Register
	PCT_INDEX             # 0x256 Index-Select Register
	PCT_MINMAXL           # 0x257 Minimum Value Registers
	PCT_MINMAXH           # 0x258 Maximum Value Registers
	PCT_RANGEL            # 0x259 Address-Range Registers
	PCT_RANGEH            # 0x25A Address-Range Registers
	PCT_UFLAGS            # 0x25B User-Flag Register
	AUX25C                # 0x25C
	AUX25D                # 0x25D
	AUX25E                # 0x25E
	AUX25F                # 0x25F
	STACK_TOP_USRT        # 0x260 User Stack Region Top Address
	STACK_BASE_USER       # 0x261 User Stack Region Base Address
	S_STACK_TOP_USER      # 0x262 Secure User Mode Secure Stack Region Top Address
	S_STACK_BASE_USER     # 0x263 Secure User Mode Secure Stack Region Base Address
	STACK_TOP_KERNEL      # 0x264 Kernel Stack Region Top Address
	STACK_BASE_KERNEL     # 0x265 Kernel Stack Region Base Address
	S_STACK_TOP_KERNEL    # 0x266 Secure Kernel Mode Secure Stack Region Top Address
	S_STACK_BASE_KERNEL   # 0x267 Secure Kernel Mode Secure Stack Region Base Address
	NSC_TABLE_TOP         # 0x268 Secure Jump and Link Indexed Top Address
	NSC_TABLE_BASE        # 0x269 Secure Jump and Link Indexed Base Address
];

define AUX_REGS_BASE offset=0xA40 size=4 [ 
	JLI_BASE              # 0x290 Jump and Link Indexed Base Address
	LDI_BASE              # 0x291 Load Indexed Base Address
	EI_BASE               # 0x292 Execute Indexed Base Address
];

define AUX_REGS_BASE offset=0xC00 size=4 [ 
	FPU_CTRL              # 0x300 Floating-Point Unit Control Register
	FPU_STATUS            # 0x301 Floating-Point Unit Status Register
	AUX_DPFP1L            # 0x302 Double-precision Floating Point D1 Lower Register
	AUX_DPFP1H            # 0x303 Double-precision Floating Point D1 Higher Register
	AUX_DPFP2L            # 0x304 Double-precision Floating Point D2 Lower Register
	AUX_DPFP2H            # 0x305 Double-precision Floating Point D2 Higher Register
];

define AUX_REGS_BASE offset=0xD40 size=4 [ 
	KEY_STORE_CTRL        # 0x350 Key Store Control Register
	KEY_STORE_PWD         # 0x351 Key Store Password Register
	KEY_STORE_ADDR        # 0x352 Key Store Address Register
	KEY_STORE_DATA        # 0x353 Key Store Data Register
	NV_ICCM_CTRL          # 0x354 NVM ICCM Control Register
	NV_ICCM_ERASE         # 0x355 NVM ICCM Erase Register
	NV_ICCM_PROG          # 0x356 NVM ICCM Programming Register
	NV_ICCM_DATA          # 0x357 NVM ICCM Data Register
	CAL_STORE_CTRL        # 0x358 Calibration Parameter Store Control Register
	CAL_STORE_ADDR        # 0x359 Calibration Parameter Store Address Register
	CAL_STORE_DATA        # 0x35A Calibration Parameter Store Data Register
	AUX35B                # 0x35B
	KEY_STORE_SID         # 0x35C Key Store SID Register
];

define AUX_REGS_BASE offset=0xE00 size=4 [ 
	RTT_ADDRESS           # 0x380 ARC RTT Address Register
	RTT_DATA              # 0x381 ARC RTT DATA Register
	RTT_COMMAND           # 0x382 ARC RTT CMD Register
];


define AUX_REGS_BASE offset=0x1000 size=4 [ 
	ERET                  # 0x400 Exception Return Address
	ERBTA                 # 0x401 Exception Return Branch Target Address
	ERSTATUS              # 0x402 Exception Return Status
	ECR                   # 0x403 Exception Cause Register
	EFA                   # 0x404 Exception Fault Address
	ESYN                  # 0x405 ECC Syndrome Register
	ERSEC_STAT            # 0x406 Exception Secure Status Register
	AUX_SEC_EXCEPT        # 0x407 Secure Exception Register
	AUX408                # 0x408
	MPU_EN                # 0x409 MPU Enable Register
	ICAUSE                # 0x40A Interrupt Cause Registers
	IRQ_SELECT            # 0x40B Interrupt Select
	IRQ_ENABLE            # 0x40C Interrupt Enable Register
	IRQ_TRIGGER           # 0x40D Interrupt Trigger Register
	AUX40E                # 0x40E
	IRQ_STATUS            # 0x40F Interrupt Status Register
	XPU                   # 0x410 User Mode Extension Enable Register
	AUX411                # 0x411
	BTA                   # 0x412 Branch Target Address
	AUX413                # 0x413
	AUX414                # 0x414
	IRQ_PULSE_CANCEL      # 0x415 Interrupt Pulse Cancel Register
	IRQ_PENDING           # 0x416 Interrupt Pending Register
	AUX417                # 0x417
	AUX418                # 0x418
	AUX419                # 0x419
	AUX41A                # 0x41A
	AUX41B                # 0x41B
	AUX41C                # 0x41C
	AUX41D                # 0x41D
	AUX41E                # 0x41E
	AUX41F                # 0x41F
	MPU_ECR               # 0x420 MPU Exception Cause Register
	AUX421                # 0x421
	MPU_RDB0              # 0x422 MPU Region Descriptor Base Registers
	MPU_RDP0              # 0x423 MPU Region Descriptor Permissions Registers
	MPU_RDB1              # 0x424 MPU Region Descriptor Base Registers
	MPU_RDP1              # 0x425 MPU Region Descriptor Permissions Registers
	MPU_RDB2              # 0x426 MPU Region Descriptor Base Registers
	MPU_RDP2              # 0x427 MPU Region Descriptor Permissions Registers
	MPU_RDB3              # 0x428 MPU Region Descriptor Base Registers
	MPU_RDP3              # 0x429 MPU Region Descriptor Permissions Registers
	MPU_RDB4              # 0x42A MPU Region Descriptor Base Registers
	MPU_RDP4              # 0x42B MPU Region Descriptor Permissions Registers
	MPU_RDB5              # 0x42C MPU Region Descriptor Base Registers
	MPU_RDP5              # 0x42D MPU Region Descriptor Permissions Registers
	MPU_RDB6              # 0x42E MPU Region Descriptor Base Registers
	MPU_RDP6              # 0x42F MPU Region Descriptor Permissions Registers
	MPU_RDB7              # 0x430 MPU Region Descriptor Base Registers
	MPU_RDP7              # 0x431 MPU Region Descriptor Permissions Registers
	MPU_RDB8              # 0x432 MPU Region Descriptor Base Registers
	MPU_RDP8              # 0x433 MPU Region Descriptor Permissions Registers
	MPU_RDB9              # 0x434 MPU Region Descriptor Base Registers
	MPU_RDP9              # 0x435 MPU Region Descriptor Permissions Registers
	MPU_RDB10             # 0x436 MPU Region Descriptor Base Registers
	MPU_RDP10             # 0x437 MPU Region Descriptor Permissions Registers
	MPU_RDB11             # 0x438 MPU Region Descriptor Base Registers
	MPU_RDP11             # 0x439 MPU Region Descriptor Permissions Registers
	MPU_RDB12             # 0x43A MPU Region Descriptor Base Registers
	MPU_RDP12             # 0x43B MPU Region Descriptor Permissions Registers
	MPU_RDB13             # 0x43C MPU Region Descriptor Base Registers
	MPU_RDP13             # 0x43D MPU Region Descriptor Permissions Registers
	MPU_RDB14             # 0x43E MPU Region Descriptor Base Registers
	MPU_RDP14             # 0x43F MPU Region Descriptor Permissions Registers
	MPU_RDB15             # 0x440 MPU Region Descriptor Base Registers
	MPU_RDP15             # 0x441 MPU Region Descriptor Permissions Registers
];

define AUX_REGS_BASE offset=0x1120 size=4 [ 
	MPU_INDEX             # 0x448 MPU Index Register
	MPU_RSTART            # 0x449 MPU Region Start Address Register
	MPU_REND              # 0x44A MPU Region End Address Register
	MPU_RPER              # 0x44B MPU Region Permission Register
	MPU_PROBE             # 0x44C MPU Probe Register
	AUX44D                # 0x44D
	AUX44E                # 0x44E
	XFLAGS                # 0x44F User Extension Flags Register
];

define AUX_REGS_BASE offset=0x1600 size=4 [ 
	ACC0_LO               # 0x580 Accumulator Low Register
	ACC0_GLO              # 0x581 Low Accumulator Guard and Status Register
	ACC0_HI               # 0x582 Accumulator High Register
	ACC0_GHI              # 0x583 High Accumulator Guard and Status Register
];

define AUX_REGS_BASE offset=0x1660 size=4 [ 
	DSP_BFLY0             # 0x598 DSP Butterfly Instructions Data Register
	AUX599                # 0x599
	AUX59A                # 0x59A
	AUX59B                # 0x59B
	AUX59C                # 0x59C
	AUX59D                # 0x59D
	DSP_FFT_CTRL          # 0x59E DSP FFT Control Register
	DSP_CTRL              # 0x59F DSP Control Register
];

define AUX_REGS_BASE offset=0x1700 size=4 [ 
	AGU_AUX_AP0           # 0x5C0 AGU Address Pointer Registers
	AGU_AUX_AP1           # 0x5C1 AGU Address Pointer Registers
	AGU_AUX_AP2           # 0x5C2 AGU Address Pointer Registers
	AGU_AUX_AP3           # 0x5C3 AGU Address Pointer Registers
	AGU_AUX_AP4           # 0x5C4 AGU Address Pointer Registers
	AGU_AUX_AP5           # 0x5C5 AGU Address Pointer Registers
	AGU_AUX_AP6           # 0x5C6 AGU Address Pointer Registers
	AGU_AUX_AP7           # 0x5C7 AGU Address Pointer Registers
	AGU_AUX_AP8           # 0x5C8 AGU Address Pointer Registers
	AGU_AUX_AP9           # 0x5C9 AGU Address Pointer Registers
	AGU_AUX_AP10          # 0x5CA AGU Address Pointer Registers
	AGU_AUX_AP11          # 0x5CB AGU Address Pointer Registers
];

define AUX_REGS_BASE offset=0x1740 size=4 [ 
	AGU_AUX_OS0           # 0x5D0 AGU Offset Registers
	AGU_AUX_OS1           # 0x5D1 AGU Offset Registers
	AGU_AUX_OS2           # 0x5D2 AGU Offset Registers
	AGU_AUX_OS3           # 0x5D3 AGU Offset Registers
	AGU_AUX_OS4           # 0x5D4 AGU Offset Registers
	AGU_AUX_OS5           # 0x5D5 AGU Offset Registers
	AGU_AUX_OS6           # 0x5D6 AGU Offset Registers
	AGU_AUX_OS7           # 0x5D7 AGU Offset Registers
];

define AUX_REGS_BASE offset=0x1780 size=4 [ 
	AGU_AUX_MOD0          # 0x5E0 AGU Modifier Registers 
	AGU_AUX_MOD1          # 0x5E1 AGU Modifier Registers 
	AGU_AUX_MOD2          # 0x5E2 AGU Modifier Registers 
	AGU_AUX_MOD3          # 0x5E3 AGU Modifier Registers
	AGU_AUX_MOD4          # 0x5E4 AGU Modifier Registers 
	AGU_AUX_MOD5          # 0x5E5 AGU Modifier Registers 
	AGU_AUX_MOD6          # 0x5E6 AGU Modifier Registers 
	AGU_AUX_MOD7          # 0x5E7 AGU Modifier Registers
	AGU_AUX_MOD8          # 0x5E8 AGU Modifier Registers 
	AGU_AUX_MOD9          # 0x5E9 AGU Modifier Registers 
	AGU_AUX_MOD10         # 0x5EA AGU Modifier Registers 
	AGU_AUX_MOD11         # 0x5EB AGU Modifier Registers
	AGU_AUX_MOD12         # 0x5EC AGU Modifier Registers 
	AGU_AUX_MOD13         # 0x5ED AGU Modifier Registers 
	AGU_AUX_MOD14         # 0x5EE AGU Modifier Registers 
	AGU_AUX_MOD15         # 0x5EF AGU Modifier Registers
	AGU_AUX_MOD16         # 0x5F0 AGU Modifier Registers 
	AGU_AUX_MOD17         # 0x5F1 AGU Modifier Registers 
	AGU_AUX_MOD18         # 0x5F2 AGU Modifier Registers 
	AGU_AUX_MOD19         # 0x5F3 AGU Modifier Registers
	AGU_AUX_MOD20         # 0x5F4 AGU Modifier Registers 
	AGU_AUX_MOD21         # 0x5F5 AGU Modifier Registers 
	AGU_AUX_MOD22         # 0x5F6 AGU Modifier Registers 
	AGU_AUX_MOD23         # 0x5F7 AGU Modifier Registers 
	XCCM_BASE             # 0x5F8 XCCM Base Address
	YCCM_BASE             # 0x5F9 YCCM Base Address
	AUX5FA                # 0x5FA
	AUX5FB                # 0x5FB
	BS_AUX_CTRL           # 0x5FC Bitstream Control Register
	BS_AUX_ADDR           # 0x5FD Bitstream Base Address Register
	BS_AUX_BIT_OS         # 0x5FE Bitstream Offset Register
	BS_AUX_WDATA          # 0x5FF Bitstream Write Data Register
	CONNECT_CMD           # 0x600 ARConnect Command Register
	CONNECT_WDATA         # 0x601 ARConnect Write Data Register
	CONNECT_READBACK      # 0x602 ARConnect Read Data Register
];

define AUX_REGS_BASE offset=0x1840 size=4 [ 
	PDM_PSTAT             # 0x610 Core Power Status Register 
	RTT_PDM_PSTAT         # 0x611 ARC RTT Power Status Register 
	AUX612                # 0x612
	PDM_PMODE             # 0x613 Power Down Register 
];

define AUX_REGS_BASE offset=0x1a00 size=4 [ 
	DMACTRL               # 0x680 DMA Controller Configuration Register 
	DMACENB               # 0x681 DMA Channel Enable Register
	DMACDSB               # 0x682 DMA Channel Disable Register 
	DMACHPRI              # 0x683 DMA Channel High Priority Level Register 
	DMACNPRI              # 0x684 DMA Channel Normal Priority Level Register 
	DMACREQ               # 0x685 DMA Channel Transfer Request Register
	DMACSTAT0             # 0x686 DMA Channel Status Register
	DMACSTAT1             # 0x687 DMA Channel Status Register 
	DMACIRQ               # 0x688 DMA Channel Interrupt Request Status Register 
	DMACBASE              # 0x689 DMA Channel Structure Base Address Register
	DMACRST               # 0x68A DMA Channel Reset Register
];

define AUX_REGS_BASE offset=0x1a40 size=4 [ 
	DMACTRL0              # 0x690 DMA Channel Control Register
	DMASAR0               # 0x691 DMA Channel Source Address Register
	DMADAR0               # 0x692 DMA Channel Destination Address Register
];

define AUX_REGS_BASE offset=0x1c00 size=4 [ 
	SMART_CONTROL         # 0x700 SmaRT Control Register 
	SMART_DATA            # 0x701 SmaRT Data Register
];

define AUX_REGS_BASE offset=0x2a00 size=4 [
	LSC_CTRL              # 0xA80 Lockstep Control Register 
	LSC_MCD               # 0xA81 Lockstep Debug Control Register 
	LSC_STATUS            # 0xA82 Lockstep Status Register 
	LSC_ERROR_REG         # 0xA83 Lockstep Error Register 
];

define AUX_REGS_BASE offset=0x3c000 size=4 [ 
	AUX_KEY_DATA          # 0xF000 Key Data Register
	AUX_KEY_UNLOCK        # 0xF001 Key Unlock Register
];


# Flags used in the system (the flags of STATUS register)
define register offset=0x120 size=1 [ IE S US AD RB ES SC DZ L Z N C V U DE AE E H ];


define register offset=0x154 size=4 [ contextreg ];
define context contextreg
  phase = (0,0) signed noflow    # 0:initial, 1:instruction-parse
  loopEnd = (1,1) signed noflow
;

# Implement loop logic, for instruction "LP"
:^instruction is phase = 0 & loopEnd=0 & instruction [phase = 1;] {
  build instruction;
}

#In my case noflow attribute did not work, so I had to use this construction: globalset(inst_start, loopEnd)
:^"loop_end."^instruction is phase=0 & loopEnd=1 & instruction [ phase = 1; loopEnd=0; globalset(inst_start, loopEnd);] {
  if (pcl != LP_END) goto <end_loop>;
  r60_lp_count = r60_lp_count - 1;
  if (r60_lp_count == 0) goto <end_loop>;
  # Load LP_START
  pcl = LP_START;
  goto [pcl];
<end_loop>
  build instruction;
}


# Update flags according to a value
macro UPDATE_FLAGS_ZN(value) {
  Z = (value == 0:4);
  N = value s< 0:4;
  #N = value[31,1]; #Alternative way of getting N bit
}

# flags before an addition
macro UPDATE_FLAGS_CV(op1, op2) {
  C = carry(op1, op2);
  V = scarry(op1, op2);
}

macro push4(x) {
  sp = sp - 4;
  *:4 sp = x;
}

macro pop(x) {
  x = *:4 sp;
  sp = sp + 4;
}

# Key for 16-bit adddestsing modes and encoding conventions (reference page 295 table 7-6)
# ======================================================================================================
# Encoding  | Encodig | Syntax
# Character | Field   | 
# ======================================================================================================
#     I     | I[4:0]  | instruction major opcode
#     i     | i[n:0]  | instruction sub-opcode
#     a     | a[2:0]  | source/destination register (r0-3,r12-15)
#     b     | b[2:0]  | source/destination register (r0-3,r12-15)
#     c     | c[2:0]  | source/destination register (r0-3,r12-15)
#     h     | h[2:0]  | source/destination register low (r0-31 excluding r29 and r30)
#     H     | H[4:3]  | source/destination register high (r0-31 excluding r29 and r30)
#     g     | g[2:0]  | destination register low (r0-31 excluding r29 and r30)
#     G     | G[4:3]  | destination register high (r0-31 excluding r29 and r30)
#     u     | u[n:0]  | unsigned immediate (number is bitfield size)
#     s     | s[n:0]  | signed immediate (number is bitfield size)

define token instr16 (16)
  F16_MAJOR_OPCODE 		= (11, 15)
  
  f16_a 				= (0, 2)

  f16_b 				= (8, 10)
  f16_b_cp 				= (8, 10)
  f16_c 				= (5, 7)
  f16_gen_op_U 			= (0, 4)
  f16_gen_op_u6 		= (5,10)

  f16_bit0 				= (0,0)
  f16_bit2 				= (2,2)
  f16_bit3 				= (3,3)
  f16_bit4 				= (4,4)
  f16_bit7 				= (7,7)
  f16_bit8 				= (8,8)
  f16_bit9 				= (9,9)
  f16_bit10 			= (10,10)
  
  f16_G 				= (3, 4)
  f16_g 				= (8, 10)
  f16_G0_g 				= (8, 10)
  f16_G1_g 				= (8, 10)
  f16_G2_g 				= (8, 10)
  f16_G3_g 				= (8, 10)
  
  f16_H 				= (0,1)
  f16_h 				= (5,7)
  f16_H0_h 				= (5,7)
  f16_H1_h 				= (5,7)
  f16_H2_h 				= (5,7)
  f16_H3_h 				= (5,7)

  f16_i 				= (3, 4)

  f16_compact_u_2_3 	= (3,4)
  f16_compact_r 		= (8,9)

  f16_ld_add_sub_r 		= (7,7)
  f16_ld_add_sub_U_0_2 	= (0,2)
  f16_ld_add_sub_U_3_5 	= (4,6)

  f16_ld_st_1_U_0_2 	= (0,2)
  f16_ld_st_1_U_3_6 	= (4,7)
  f16_ld_st_1_S_2_4 	= (0,2)
  f16_ld_st_1_S_5_10 	= (5,10) signed

  f16_fli_ei_U_0_9 		= (0,9)

  f16_add_imm_U 		= (0,2)

  f16_op_hreg_S 		= (8,10) signed
  f16_op_hreg_H 		= (0,1)
  f16_op_hreg_h 		= (5,7)
  f16_op_hreg_H0_h 		= (5,7)
  f16_op_hreg_H1_h 		= (5,7)
  f16_op_hreg_H2_h 		= (5,7)
  f16_op_hreg_H3_h 		= (5,7)

  f16_ld_word_U 		= (0,4)

  f16_sh_sub_bit_i 		= (5,7)
  f16_sh_sub_bit_U 		= (0,4)

  f16_sp_ops_i 			= (5,7)
  f16_sp_ops_u_0_4 		= (0,4)

  f16_sp_ops_u_0_3 		= (1,4)
  f16_sp_ops_u_4_6 		= (8,10)
  f16_sp_ops_u_4_5 		= (8,9)

  f16_gp_add_load_i 	= (9, 10)
  f16_gp_add_load_S 	= (0,8) signed

  f16_pcl_ld_U 			= (0,7)

  f16_mv_imm_U 			= (0,7)

  f16_op_imm_U 			= (0,6)

  f16_bcc_reg_S 		= (0,6) signed

  f16_bcc_reg_S_1_9 	= (0,8) signed
  f16_bcc_reg_S_1_6 	= (0,5) signed
  f16_bcc_reg_i 		= (6,8)

  f16_bl_S 				= (0,10) signed
;


# Key for 32-bit adddestsing modes and encoding conventions (reference page 294-295 table 7-5)
# ======================================================================================================
# Encoding  | Encodig | Syntax
# Character | Field   | 
# ======================================================================================================
#     I     | I[4:0]  | instruction major opcode
#     i     | i[n:0]  | instruction sub-opcode
#     A     | A[5:0]  | destination register
#     b     | B[2:0]  | lower bits source/destination register
#     B     | B[5:3]  | upper bits source/destination register
#     C     | C[5:0]  | source/destination register
#     Q     | Q[4:0]  | <cc> condition code
#     u     | U[n:0]  | unsigned immediate (number is bitfield size)
#     s     | S[n:0]  | lower bits signed immediate (number is bitfield size)
#     S     | S[m:n+1]| upper bits signed immediate (number is bitfield size)
#     T     | S[24:21]| upper bits signed immediate (branch unconditionally far)
#     w     | W[5:0]  | signed immediate 6-bit store data value
#     P     | P[1:0]  | operand format
#     M     | M       | conditional instruction operand mode
#     N     | N       | <.d> delay slot mode
#     F     | F       | flag setting
#     R     | R       | desterved
#     D     | D       | <.di> direct data cache bypass
#     a     | a[1:0]  | <.aa> adddests writeback mode
#     Z     | Z[1:0]  | <.zz> data size
#     X     | X       | <.x> sign extend
#     K     | K       | <.k> store constant operand mode

define token instr32 (32)                                                       
  F32_MAJOR_OPCODE              = (11, 15)                                                       
                                                        
  f32_delay_bit                 = (21,21)                                                       

  
  f32_bit23                     = (7, 7)
  f32_bit22                     = (6, 6) 
  f32_bits_22_23                = (6, 7)  
  f32_bit17                     = (1, 1)                                                        
  f32_bit16                     = (0, 0) 

  f32_bit15                     = (31, 31)
  f32_bit5                      = (21, 21)                                                        
  f32_bit4                      = (20, 20)   
  f32_bit0                      = (16, 16)                                                     
                                                        
  f32_br0_S_1_10                = (1, 10)   
  f32_br0_S_11_20_cp            = (22, 31)                                                     
  f32_br0_S_11_20               = (22, 31) signed                                                       
  f32_Q                         = (16, 20)                                                        
  f32_br0_S_21_24               = (16, 19) signed                                                        
                                                        
  f32_br1_S_2_10                = (2, 10)                                                        
  f32_br1_S_11_20               = (22, 31) signed
  f32_br1_S_11_20_cp			= (22, 31)
  f32_br1_S_21_24               = (16, 19) signed                                                       
  f32_br1_i_0_2                 = (16, 18)                                                        
  f32_br1_i_0_3                 = (16, 19)                                                        
  f32_C                         = (22, 27)                                                        
  f32_br1_U                     = (22, 27)                                                        
                                                                        
  f32_B_3_5                     = (28,30)                                                                                                            
                                                        
  f32_B0_b_0_2                  = (8,10)                                                       
  f32_B1_b_0_2                  = (8,10)                                                       
  f32_B2_b_0_2                  = (8,10)                                                       
  f32_B3_b_0_2                  = (8,10)                                                       
  f32_B4_b_0_2                  = (8,10)                                                       
  f32_B5_b_0_2                  = (8,10)                                                       
  f32_B6_b_0_2                  = (8,10)                                                       
  f32_B7_b_0_2                  = (8,10)                                                       
                                                        
  f32_br1_S_1_7                 = (1,7)                                                       
  f32_br1_S_8_8                 = (31,31) signed                                                      
  f32_br1_branch_prediction_bit = (19,19)  

  f32_A                         = (16, 21)
  f32_A_ext5					= (16, 21)
  f32_ld_offset_X               = (22, 22)
  f32_ld_offset_ZZ              = (23, 24)
  f32_ld_offset_ZZ_cp           = (23, 24)
  f32_ld_offset_aa              = (25, 26)
  f32_ld_offset_D               = (27, 27)
  f32_ld_offset_S_8_8           = (31, 31) signed
  f32_ld_offset_S_0_7           = (0, 7)     

  f32_st_offset_ZZ              = (17, 18)
  f32_st_offset_aa              = (19, 20)
  f32_st_offset_d               = (21, 21)
  f32_st_offset_W               = (22, 27) signed
  f32_st_offset_S_0_7           = (0, 7)
  f32_st_offset_S_8_8           = (31, 31) signed

  f32_gen4_dop_S_6_11           = (16, 21) signed
  f32_gen4_dop_R_0_5            = (16, 21)
  f32_gen4_dop_U6               = (22, 27)
  f32_gen4_dop_S_5_0            = (22, 27)

  f32_bit_F                		= (31, 31)
  f32_gen4_dop_D                = (31, 31)
  f32_gen4_dop_N                = (0, 0)
  f32_gen4_dop_i_1_5            = (1, 5)
  f32_gen4_dop_i                = (0, 5)
  f32_gen4_dop_X                = (0, 0)
  f32_gen4_dop_ZZ               = (1, 2)
  f32_gen4_dop_bits_19_21       = (3, 5)
  f32_gen4_dop_aa               = (6, 7)

  f32_gen4_sop_i                = (16, 21)
  f32_gen4_sop_U6               = (22, 27)
  f32_gen4_sop_C                = (22, 27)

  f32_gen4_sop_bits_16_21       = (0, 5)
  
  f32_C_aux_src					= (22, 27)

  f32_ext_dop_S_6_11           = (16, 21) signed
  f32_ext_dop_S_5_0            = (22, 27)
  f32_ext_dop_U_6_11           = (16, 21)
  f32_ext_dop_U_5_0            = (22, 27)

  f32_ext_dop_U6               = (22, 27)
  f32_ext_dop_i                = (0, 5)
;



define token limm_lo_token (16) limm_lo = (0, 15);
define token limm_hi_token (16) limm_hi = (0, 15);

attach variables [ f16_a f16_b f16_b_cp f16_c ] [ r0 r1 r2 r3 r12 r13 r14 r15 ];

attach variables [ f16_G0_g f16_H0_h f16_op_hreg_H0_h ] [r0  r1  r2  r3  r4  r5  r6  r7];
attach variables [ f16_G1_g f16_H1_h f16_op_hreg_H1_h ] [r8  r9  r10 r11 r12 r13 r14 r15];
attach variables [ f16_G2_g f16_H2_h f16_op_hreg_H2_h ] [r16 r17 r18 r19 r20 r21 r22 r23];
attach variables [ f16_G3_g f16_H3_h f16_op_hreg_H3_h ] [r24 r25 gp  fp  sp  _   _   blink];

attach variables [ f32_B0_b_0_2 ] [r0  r1  r2   r3   r4           r5  r6      r7];
attach variables [ f32_B1_b_0_2 ] [r8  r9  r10  r11  r12          r13 r14     r15];
attach variables [ f32_B2_b_0_2 ] [r16 r17 r18  r19  r20          r21 r22     r23];
attach variables [ f32_B3_b_0_2 ] [r24 r25 gp   fp   sp           ilink   r30 blink];
attach variables [ f32_B4_b_0_2 ] [r32 r33 r34  r35  r36          r37 r38     r39 ];
attach variables [ f32_B5_b_0_2 ] [r40 r41 r42  r43  r44          r45 r46     r47 ];
attach variables [ f32_B6_b_0_2 ] [r48 r49 r50  r51  r52          r53 r54     r55 ];
attach variables [ f32_B7_b_0_2 ] [r56 r57 accl acch r60_lp_count _   _       _ ];

attach variables [ f32_A f32_C ] [r0  r1  r2   r3   r4            r5    r6  r7
                                  r8  r9  r10  r11  r12           r13   r14 r15
                                  r16 r17 r18  r19  r20           r21   r22 r23
                                  r24 r25 gp   fp   sp            ilink r30 blink
                                  r32 r33 r34  r35  r36           r37   r38 r39    
                                  r40 r41 r42  r43  r44           r45   r46 r47 
                                  r48 r49 r50  r51  r52           r53   r54 r55 
                                  r56 r57 accl acch r60_lp_count  _     _   _ ];



attach variables [ f16_compact_r ] [r0 r1 r2 r3];
attach variables [ f16_ld_add_sub_r ] [r0 r1];

attach names [ f16_sp_ops_u_0_3 ] [ "" "r13" "r13-r14" "r13-r15" "r13-r16" "r13-r17" "r13-r18" "r13-r19" "r13-r20" "r13-r21" "r13-r22" "r13-r23" "r13-r24" "r13-r25" "r13-r26" _ ];
attach names [ f16_sp_ops_u_4_5 ] [ "" ",fp" ",blink" ",fp,blink" ];
attach names [ f16_sp_ops_u_4_6 ] [ "" ",fp" ",blink" ",fp,blink" "pcl" ",fp,pcl" ",blink,pcl" ",fp,blink,pcl" ];


#Inverted enter_s implementation to reduce the number of used local variables
enter_s_fp_part1: "fp" is f16_bit8=0b0 { }
enter_s_fp_part1: "fp" is f16_bit8=0b1 { 
  push4(fp);
}

enter_s_fp_part2: "fp" is f16_bit8=0b0 { }
enter_s_fp_part2: "fp" is f16_bit8=0b1 { 
  fp = sp;
}

enter_s_blink: "blink" is f16_bit9=0b0 { }
enter_s_blink: "blink" is f16_bit9=0b1 { 
  push4(blink);
}

enter_s_regs: "" is f16_sp_ops_u_0_3=0b0000 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;
  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13" is f16_sp_ops_u_0_3=0b0001 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r14" is f16_sp_ops_u_0_3=0b0010 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r15" is f16_sp_ops_u_0_3=0b0011 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r16" is f16_sp_ops_u_0_3=0b0100 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r17" is f16_sp_ops_u_0_3=0b0101 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r18" is f16_sp_ops_u_0_3=0b0110 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r19" is f16_sp_ops_u_0_3=0b0111 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r20" is f16_sp_ops_u_0_3=0b1000 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r20);
  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r21" is f16_sp_ops_u_0_3=0b1001 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r21);
  push4(r20);
  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r22" is f16_sp_ops_u_0_3=0b1010 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r22);
  push4(r21);
  push4(r20);
  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r23" is f16_sp_ops_u_0_3=0b1011 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r23);
  push4(r22);
  push4(r21);
  push4(r20);
  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r24" is f16_sp_ops_u_0_3=0b1100 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r24);
  push4(r23);
  push4(r22);
  push4(r21);
  push4(r20);
  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r25" is f16_sp_ops_u_0_3=0b1101 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(r25);
  push4(r24);
  push4(r23);
  push4(r22);
  push4(r21);
  push4(r20);
  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}

enter_s_regs: "r13-r26" is f16_sp_ops_u_0_3=0b1110 & enter_s_fp_part1 & enter_s_fp_part2 & enter_s_blink {
  build enter_s_fp_part1;

  push4(gp);
  push4(r25);
  push4(r24);
  push4(r23);
  push4(r22);
  push4(r21);
  push4(r20);
  push4(r19);
  push4(r18);
  push4(r17);
  push4(r16);
  push4(r15);
  push4(r14);
  push4(r13);

  build enter_s_blink;
  build enter_s_fp_part2;
}




#leave_s direct implementation
leave_s_fp_part2: "fp" is f16_sp_ops_u_0_3 & f16_bit8=0b0 & f16_bit9 { }
leave_s_fp_part2: "fp" is f16_sp_ops_u_0_3 & f16_bit8=0b1 & f16_bit9 { 
  pop(fp);
}

leave_s_fp_part1: "fp" is f16_sp_ops_u_0_3 & f16_bit8=0b0 & f16_bit9 { }
leave_s_fp_part1: "fp" is f16_sp_ops_u_0_3 & f16_bit8=0b1 & f16_bit9 { 
  sp = fp;
}

leave_s_blink: "blink" is f16_sp_ops_u_0_3 & f16_bit8 & f16_bit9=0b0 { }
leave_s_blink: "blink" is f16_sp_ops_u_0_3 & f16_bit8 & f16_bit9=0b1 { 
  pop(blink);
}

leave_s_ret: "blink" is f16_sp_ops_u_0_3 & f16_bit10=0b0 { }
leave_s_ret: "blink" is f16_sp_ops_u_0_3 & f16_bit10=0b1 { 
  return [blink];
}

leave_s_regs: "" is f16_sp_ops_u_0_3=0b0000 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13" is f16_sp_ops_u_0_3=0b0001 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r14" is f16_sp_ops_u_0_3=0b0010 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r15" is f16_sp_ops_u_0_3=0b0011 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r16" is f16_sp_ops_u_0_3=0b0100 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r17" is f16_sp_ops_u_0_3=0b0101 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r18" is f16_sp_ops_u_0_3=0b0110 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r19" is f16_sp_ops_u_0_3=0b0111 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r20" is f16_sp_ops_u_0_3=0b1000 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);
  pop(r20);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r21" is f16_sp_ops_u_0_3=0b1001 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);
  pop(r20);
  pop(r21);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r22" is f16_sp_ops_u_0_3=0b1010 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);
  pop(r20);
  pop(r21);
  pop(r22);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r23" is f16_sp_ops_u_0_3=0b1011 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);
  pop(r20);
  pop(r21);
  pop(r22);
  pop(r23);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r24" is f16_sp_ops_u_0_3=0b1100 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);
  pop(r20);
  pop(r21);
  pop(r22);
  pop(r23);
  pop(r24);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r25" is f16_sp_ops_u_0_3=0b1101 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);
  pop(r20);
  pop(r21);
  pop(r22);
  pop(r23);
  pop(r24);
  pop(r25);

  build leave_s_fp_part2;
  build leave_s_ret;
}

leave_s_regs: "r13-r26" is f16_sp_ops_u_0_3=0b1110 & leave_s_fp_part1 & leave_s_fp_part2 & leave_s_blink & leave_s_ret {
  build leave_s_fp_part1;
  build leave_s_blink;
  
  pop(r13);
  pop(r14);
  pop(r15);
  pop(r16);
  pop(r17);
  pop(r18);
  pop(r19);
  pop(r20);
  pop(r21);
  pop(r22);
  pop(r23);
  pop(r24);
  pop(r25);
  pop(gp);

  build leave_s_fp_part2;
  build leave_s_ret;
}






# Strangly the tables f16_G_g and f16_H_h shall go after the attach variables definition
# This is most probably due to "exporting".
# This is a trick to bypass limitation of contigous bits registers
# G is the 2 MSB bits and g is 3 LSB bits is a destination register
f16_G_g: f16_G0_g is f16_G=0 & f16_G0_g { export f16_G0_g; }
f16_G_g: f16_G1_g is f16_G=1 & f16_G1_g { export f16_G1_g; }
f16_G_g: f16_G2_g is f16_G=2 & f16_G2_g { export f16_G2_g; }
f16_G_g: f16_G3_g is f16_G=3 & f16_G3_g { export f16_G3_g; }

# H is the 2 MSB bits and h is 3 LSB bits is a source register
f16_H_h: f16_H0_h is f16_H=0 & f16_H0_h { export f16_H0_h; }
f16_H_h: f16_H1_h is f16_H=1 & f16_H1_h { export f16_H1_h; }
f16_H_h: f16_H2_h is f16_H=2 & f16_H2_h { export f16_H2_h; }
f16_H_h: f16_H3_h is f16_H=3 & f16_H3_h { export f16_H3_h; }

f16_op_hreg_H_h: f16_op_hreg_H0_h is f16_op_hreg_H=0 & f16_op_hreg_H0_h { export f16_op_hreg_H0_h; }
f16_op_hreg_H_h: f16_op_hreg_H1_h is f16_op_hreg_H=1 & f16_op_hreg_H1_h { export f16_op_hreg_H1_h; }
f16_op_hreg_H_h: f16_op_hreg_H2_h is f16_op_hreg_H=2 & f16_op_hreg_H2_h { export f16_op_hreg_H2_h; }
f16_op_hreg_H_h: f16_op_hreg_H3_h is f16_op_hreg_H=3 & f16_op_hreg_H3_h { export f16_op_hreg_H3_h; }

f16_op_hreg_H_h_cp: f16_op_hreg_H0_h is f16_op_hreg_H=0 & f16_op_hreg_H0_h { export f16_op_hreg_H0_h; }
f16_op_hreg_H_h_cp: f16_op_hreg_H1_h is f16_op_hreg_H=1 & f16_op_hreg_H1_h { export f16_op_hreg_H1_h; }
f16_op_hreg_H_h_cp: f16_op_hreg_H2_h is f16_op_hreg_H=2 & f16_op_hreg_H2_h { export f16_op_hreg_H2_h; }
f16_op_hreg_H_h_cp: f16_op_hreg_H3_h is f16_op_hreg_H=3 & f16_op_hreg_H3_h { export f16_op_hreg_H3_h; }

f16_compact_U:    value is f16_bit10 & f16_compact_u_2_3                [ value=(f16_bit10 << 4) + (f16_compact_u_2_3 << 2); ]          { export *[const]:4 value; }

f16_ld_add_sub_U: value is f16_ld_add_sub_U_0_2 & f16_ld_add_sub_U_3_5  [ value=(f16_ld_add_sub_U_3_5 << 3) + f16_ld_add_sub_U_0_2; ]   { export *[const]:4 value; }

f16_ld_st_1_U:    value is f16_ld_st_1_U_0_2 & f16_ld_st_1_U_3_6        [ value=(f16_ld_st_1_U_3_6 << 3) + f16_ld_st_1_U_0_2; ]         { export *[const]:4 value; }

f16_ld_st_1_S:    value is f16_ld_st_1_S_2_4 & f16_ld_st_1_S_5_10       [ value=(f16_ld_st_1_S_5_10 << 5) + (f16_ld_st_1_S_2_4 << 2); ] { export *[const]:4 value; }

f16_sp_ops_simple_u7:    value is f16_sp_ops_u_0_4                      [ value= f16_sp_ops_u_0_4 << 2; ]                               { export *[const]:4 value; }



f16_ld_word_u7:   value is f16_ld_word_U                                [ value=f16_ld_word_U << 2; ]                                   { export *[const]:4 value; }
f16_ld_word_u6:   value is f16_ld_word_U                                [ value=f16_ld_word_U << 1; ]                                   { export *[const]:4 value; }
f16_ld_word_u5:   value is f16_ld_word_U                                [ value=f16_ld_word_U + 0; ]                                    { export *[const]:4 value; }


f16_bcc_reg_S8:   value is f16_bcc_reg_S                                [ value=(inst_start & ~3) + (f16_bcc_reg_S << 1); ]             { export *[ram]:4 value; }
f16_bcc_s10:      value is f16_bcc_reg_S_1_9                            [ value=(inst_start & ~3) + (f16_bcc_reg_S_1_9 << 1); ]         { export *[ram]:4 value; }
f16_bcc_s7:       value is f16_bcc_reg_S_1_6                            [ value=(inst_start & ~3) + (f16_bcc_reg_S_1_6 << 1); ]         { export *[ram]:4 value; }
f16_bl_s13:       value is f16_bl_S                                     [ value=(inst_start & ~3) + (f16_bl_S << 2); ]                  { export *[ram]:4 value; }
        
limm: limm is limm_hi ; limm_lo [ limm = (limm_hi << 16) + limm_lo; ] { export *[const]:4 limm; }



# Definitions FOR F32_BR0
f32_br0_S21:      value is f32_br0_S_1_10 & f32_br0_S_11_20                     	[ value=(inst_start & ~3) + (f32_br0_S_11_20 << 11) + (f32_br0_S_1_10 << 1); ]                                  { export *[ram]:4 value; }
f32_br0_S25:      value is f32_br0_S_1_10 & f32_br0_S_11_20_cp & f32_br0_S_21_24   	[ value=(inst_start & ~3) + (f32_br0_S_21_24 << 21) + (f32_br0_S_11_20_cp << 11) + (f32_br0_S_1_10 << 1); ] 	{ export *[ram]:4 value; }

# Definitions FOR F32_BR1
f32_br1_C_U6_src: limm     			is f32_C=0b111110 		& f32_bit4=0b0; limm 		{ export *[const]:4 limm; }
f32_br1_C_U6_src: f32_C    			is f32_C 				& f32_bit4=0b0          	{ export f32_C; }
f32_br1_C_U6_src: f32_br1_U    		is f32_br1_U 			& f32_bit4=0b1				{ export *[const]:4 f32_br1_U; }

f32_br1_S9:       value is f32_br1_S_8_8 & f32_br1_S_1_7                        	[ value=(inst_start & ~3) + (f32_br1_S_8_8 << 8)    + (f32_br1_S_1_7 << 1);]                               	{ export *[ram]:4 value; }
f32_br1_S21:      value is f32_br1_S_2_10 & f32_br1_S_11_20                     	[ value=(inst_start & ~3) + (f32_br1_S_11_20 << 11) + (f32_br1_S_2_10 << 2);]                           	{ export *[ram]:4 value; }
f32_br1_S25:      value is f32_br1_S_2_10 & f32_br1_S_11_20_cp & f32_br1_S_21_24   	[ value=(inst_start & ~3) + (f32_br1_S_21_24 << 21) + (f32_br1_S_11_20_cp << 11) + (f32_br1_S_2_10 << 2);] 	{ export *[ram]:4 value; }

# Definitions FOR F32_LD_OFFSET load instruction
f32_ld_offset_S9_aa_zz_src: value 	is f32_ld_offset_S_8_8 & f32_ld_offset_S_0_7 & f32_ld_offset_aa=0b00           							[ value=(f32_ld_offset_S_8_8 << 8)  + f32_ld_offset_S_0_7;]      		{ export *[const]:4 value; }
f32_ld_offset_S9_aa_zz_src: value 	is f32_ld_offset_S_8_8 & f32_ld_offset_S_0_7 & f32_ld_offset_aa=0b01           							[ value=(f32_ld_offset_S_8_8 << 8)  + f32_ld_offset_S_0_7;]      		{ export *[const]:4 value; }
f32_ld_offset_S9_aa_zz_src: value 	is f32_ld_offset_S_8_8 & f32_ld_offset_S_0_7 & f32_ld_offset_aa=0b10           							[ value=(f32_ld_offset_S_8_8 << 8)  + f32_ld_offset_S_0_7;]      		{ export *[const]:4 value; }
f32_ld_offset_S9_aa_zz_src: value 	is f32_ld_offset_S_8_8 & f32_ld_offset_S_0_7 & f32_ld_offset_aa=0b11 & f32_ld_offset_ZZ=0b00           	[ value=(f32_ld_offset_S_8_8 << 10) + (f32_ld_offset_S_0_7 << 2);]      { export *[const]:4 value; }
f32_ld_offset_S9_aa_zz_src: value 	is f32_ld_offset_S_8_8 & f32_ld_offset_S_0_7 & f32_ld_offset_aa=0b11 & f32_ld_offset_ZZ=0b10           	[ value=(f32_ld_offset_S_8_8 << 9)  + (f32_ld_offset_S_0_7 << 1);]      { export *[const]:4 value; }
f32_ld_offset_S9_aa_zz_src: value 	is f32_ld_offset_S_8_8 & f32_ld_offset_S_0_7 & f32_ld_offset_aa=0b11 & f32_ld_offset_ZZ=0b11           	[ value=(f32_ld_offset_S_8_8 << 10) + (f32_ld_offset_S_0_7 << 2);]      { export *[const]:4 value; }



# Definitions FOR F32_ST_OFFSET
f32_st_offset_C_W_dst: limm     			is f32_C=0b111110 		& f32_bit0=0b0; limm 		{ export *[const]:4 limm; }
f32_st_offset_C_W_dst: f32_C    			is f32_C 				& f32_bit0=0b0          	{ export f32_C; }
f32_st_offset_C_W_dst: f32_st_offset_W     	is f32_st_offset_W 		& f32_bit0=0b1				{ export *[const]:4 f32_st_offset_W; }

#f32_st_offset_S9_aa_zz_src: value 	is f32_st_offset_S_8_8=0b0 & f32_st_offset_S_0_7=0b00000000           									[ value=0 ;]      												{ export *[const]:4 value; }
f32_st_offset_S9_aa_zz_src: value 	is f32_st_offset_S_8_8 & f32_st_offset_S_0_7 & f32_st_offset_aa=0b00           							[ value=(f32_st_offset_S_8_8 << 8)  + f32_st_offset_S_0_7;]      		{ export *[const]:4 value; }
f32_st_offset_S9_aa_zz_src: value 	is f32_st_offset_S_8_8 & f32_st_offset_S_0_7 & f32_st_offset_aa=0b01           							[ value=(f32_st_offset_S_8_8 << 8)  + f32_st_offset_S_0_7;]      		{ export *[const]:4 value; }
f32_st_offset_S9_aa_zz_src: value 	is f32_st_offset_S_8_8 & f32_st_offset_S_0_7 & f32_st_offset_aa=0b10           							[ value=(f32_st_offset_S_8_8 << 8)  + f32_st_offset_S_0_7;]      		{ export *[const]:4 value; }
f32_st_offset_S9_aa_zz_src: value 	is f32_st_offset_S_8_8 & f32_st_offset_S_0_7 & f32_st_offset_aa=0b11 & f32_st_offset_ZZ=0b00           	[ value=(f32_st_offset_S_8_8 << 10) + (f32_st_offset_S_0_7 << 2);]      { export *[const]:4 value; }
f32_st_offset_S9_aa_zz_src: value 	is f32_st_offset_S_8_8 & f32_st_offset_S_0_7 & f32_st_offset_aa=0b11 & f32_st_offset_ZZ=0b10           	[ value=(f32_st_offset_S_8_8 << 9)  + (f32_st_offset_S_0_7 << 1);]      { export *[const]:4 value; }
f32_st_offset_S9_aa_zz_src: value 	is f32_st_offset_S_8_8 & f32_st_offset_S_0_7 & f32_st_offset_aa=0b11 & f32_st_offset_ZZ=0b11           	[ value=(f32_st_offset_S_8_8 << 10) + (f32_st_offset_S_0_7 << 2);]      { export *[const]:4 value; }

#F32_GEN4 values
#f32_bi_addr: value is f32_C=0b111110; limm 	[value = inst_next + limm;] 		{export *[ram]:4 value; }
#f32_bi_addr: value is f32_C 				[value = inst_next + (f32_C << 2);] {export *[ram]:4 value; }



f32_A_dst: value    is f32_A=0b111110     [value=0;]	{ export *[const]:4 value;}
f32_A_dst: f32_A    is f32_A              				{ export f32_A; }

f32_B_dst: value        is f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 	  [value=0;] { export *[const]:4 value; }
f32_B_dst: f32_B0_b_0_2 is f32_B_3_5=0 & f32_B0_b_0_2                 { export f32_B0_b_0_2; }
f32_B_dst: f32_B1_b_0_2 is f32_B_3_5=1 & f32_B1_b_0_2                 { export f32_B1_b_0_2; }
f32_B_dst: f32_B2_b_0_2 is f32_B_3_5=2 & f32_B2_b_0_2                 { export f32_B2_b_0_2; }
f32_B_dst: f32_B3_b_0_2 is f32_B_3_5=3 & f32_B3_b_0_2                 { export f32_B3_b_0_2; }
f32_B_dst: f32_B4_b_0_2 is f32_B_3_5=4 & f32_B4_b_0_2                 { export f32_B4_b_0_2; }
f32_B_dst: f32_B5_b_0_2 is f32_B_3_5=5 & f32_B5_b_0_2                 { export f32_B5_b_0_2; }
f32_B_dst: f32_B6_b_0_2 is f32_B_3_5=6 & f32_B6_b_0_2                 { export f32_B6_b_0_2; }
f32_B_dst: f32_B7_b_0_2 is f32_B_3_5=7 & f32_B7_b_0_2                 { export f32_B7_b_0_2; }

f32_B_src: limm         is f32_B_3_5=0b111 & f32_B7_b_0_2=0b110; limm { export *[const]:4 limm; }
f32_B_src: f32_B0_b_0_2 is f32_B_3_5=0 & f32_B0_b_0_2                 { export f32_B0_b_0_2; }
f32_B_src: f32_B1_b_0_2 is f32_B_3_5=1 & f32_B1_b_0_2                 { export f32_B1_b_0_2; }
f32_B_src: f32_B2_b_0_2 is f32_B_3_5=2 & f32_B2_b_0_2                 { export f32_B2_b_0_2; }
f32_B_src: f32_B3_b_0_2 is f32_B_3_5=3 & f32_B3_b_0_2                 { export f32_B3_b_0_2; }
f32_B_src: f32_B4_b_0_2 is f32_B_3_5=4 & f32_B4_b_0_2                 { export f32_B4_b_0_2; }
f32_B_src: f32_B5_b_0_2 is f32_B_3_5=5 & f32_B5_b_0_2                 { export f32_B5_b_0_2; }
f32_B_src: f32_B6_b_0_2 is f32_B_3_5=6 & f32_B6_b_0_2                 { export f32_B6_b_0_2; }
f32_B_src: f32_B7_b_0_2 is f32_B_3_5=7 & f32_B7_b_0_2                 { export f32_B7_b_0_2; }

f32_C_src: limm     is f32_C=0b111110; limm { export *[const]:4 limm; }
f32_C_src: f32_C    is f32_C                { export f32_C; }

# Definitions FOR F32_GEN4 load instruction
f32_gen4_C_aa_zz_src: f32_C 	is f32_gen4_dop_aa=0b00 & f32_C          			{ export f32_C;            }
f32_gen4_C_aa_zz_src: limm 	is f32_gen4_dop_aa=0b00 & f32_C=0b111110; limm  { export *[const]:4 limm;  }
f32_gen4_C_aa_zz_src: f32_C 	is f32_gen4_dop_aa=0b01 & f32_C          			{ export f32_C;            }
f32_gen4_C_aa_zz_src: limm 	is f32_gen4_dop_aa=0b01 & f32_C=0b111110; limm  { export *[const]:4 limm;  }
f32_gen4_C_aa_zz_src: f32_C 	is f32_gen4_dop_aa=0b10 & f32_C          			{ export f32_C;            }
f32_gen4_C_aa_zz_src: limm 	is f32_gen4_dop_aa=0b10 & f32_C=0b111110; limm  { export *[const]:4 limm;  }
f32_gen4_C_aa_zz_src: value 	is f32_gen4_dop_aa=0b11 & f32_gen4_dop_ZZ=0b00 & f32_C                    [ value=f32_C << 2;]    { export *[const]:4 value; }
f32_gen4_C_aa_zz_src: limm 	is f32_gen4_dop_aa=0b11 & f32_gen4_dop_ZZ=0b00 & f32_C=0b111110; limm                               { export *[const]:4 limm; }
f32_gen4_C_aa_zz_src: value 	is f32_gen4_dop_aa=0b11 & f32_gen4_dop_ZZ=0b10 & f32_C                    [ value=f32_C << 1;]    { export *[const]:4 value; }
f32_gen4_C_aa_zz_src: limm 	is f32_gen4_dop_aa=0b11 & f32_gen4_dop_ZZ=0b10 & f32_C=0b111110; limm                               { export *[const]:4 limm; }
f32_gen4_C_aa_zz_src: value 	is f32_gen4_dop_aa=0b11 & f32_gen4_dop_ZZ=0b11 & f32_C                    [ value=f32_C << 2;]    { export *[const]:4 value; }
f32_gen4_C_aa_zz_src: limm 	is f32_gen4_dop_aa=0b11 & f32_gen4_dop_ZZ=0b11 & f32_C=0b111110; limm                               { export *[const]:4 limm; }





f32_A_B_dst: f32_A 		  is (f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A                 									{ export f32_A; } 
f32_A_B_dst: value 		  is (f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110				 			[value=0;]		{ export *[const]:4 value;}
f32_A_B_dst: value        is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 	[value=0;]		{ export *[const]:4 value;}
f32_A_B_dst: f32_B0_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0 & f32_B0_b_0_2                 				{ export f32_B0_b_0_2; }
f32_A_B_dst: f32_B1_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=1 & f32_B1_b_0_2                 				{ export f32_B1_b_0_2; }
f32_A_B_dst: f32_B2_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=2 & f32_B2_b_0_2                 				{ export f32_B2_b_0_2; }
f32_A_B_dst: f32_B3_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=3 & f32_B3_b_0_2                 				{ export f32_B3_b_0_2; }
f32_A_B_dst: f32_B4_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=4 & f32_B4_b_0_2                 				{ export f32_B4_b_0_2; }
f32_A_B_dst: f32_B5_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=5 & f32_B5_b_0_2                 				{ export f32_B5_b_0_2; }
f32_A_B_dst: f32_B6_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=6 & f32_B6_b_0_2                 				{ export f32_B6_b_0_2; }
f32_A_B_dst: f32_B7_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=7 & f32_B7_b_0_2                 				{ export f32_B7_b_0_2; }

f32_C_U6_src: limm     			is f32_C=0b111110 		& (f32_bits_22_23=0b00); limm 	{ export *[const]:4 limm; }
f32_C_U6_src: f32_C    			is f32_C 				& (f32_bits_22_23=0b00)         { export f32_C; }
f32_C_U6_src: f32_gen4_dop_U6  	is f32_gen4_dop_U6 		& (f32_bits_22_23=0b01)       	{ export *[const]:4 f32_gen4_dop_U6; }


f32_C_U6_S12_src: limm     			is f32_C=0b111110 		& (f32_bits_22_23=0b00 | (f32_bits_22_23=0b11 & f32_bit5=0b0)); limm 	{ export *[const]:4 limm; }
f32_C_U6_S12_src: f32_C    			is f32_C 				& (f32_bits_22_23=0b00 | (f32_bits_22_23=0b11 & f32_bit5=0b0))          { export f32_C; }
f32_C_U6_S12_src: f32_gen4_dop_U6  	is f32_gen4_dop_U6 		& (f32_bits_22_23=0b01 | (f32_bits_22_23=0b11 & f32_bit5=0b1))       	{ export *[const]:4 f32_gen4_dop_U6; }
f32_C_U6_S12_src: value  			is f32_gen4_dop_S_6_11 	& f32_gen4_dop_S_5_0 & f32_bits_22_23=0b10            [ value = (f32_gen4_dop_S_6_11 << 6) + f32_gen4_dop_S_5_0;]                         { export *[const]:4 value; }

f32_C_U6_S12_src_for_jump: limm     			    is f32_C=0b111110 		  & (f32_bits_22_23=0b00 | (f32_bits_22_23=0b11 & f32_bit5=0b0)); limm 	                                                    { export *[const]:4 limm; }
f32_C_U6_S12_src_for_jump: f32_C    			    is f32_C 				        & (f32_bits_22_23=0b00 | (f32_bits_22_23=0b11 & f32_bit5=0b0))                                                            { export f32_C; }
f32_C_U6_S12_src_for_jump: f32_gen4_dop_U6  	is f32_gen4_dop_U6 		  & (f32_bits_22_23=0b01 | (f32_bits_22_23=0b11 & f32_bit5=0b1))       	                                                    { export *[ram]:4 f32_gen4_dop_U6; }
f32_C_U6_S12_src_for_jump: value  				    is f32_gen4_dop_S_6_11 	& f32_gen4_dop_S_5_0  & f32_bits_22_23=0b10                   [ value = (f32_gen4_dop_S_6_11 << 6) + f32_gen4_dop_S_5_0;] { export *[ram]:4 value; }


f32_gen4_lp_U7_S13: value is f32_gen4_dop_S_6_11 & f32_gen4_dop_S_5_0 & f32_bits_22_23=0b10        [ value = (inst_start & ~3) + (f32_gen4_dop_S_6_11 << 7) + (f32_gen4_dop_S_5_0<<1);]     { export *[ram]:4 value; }
f32_gen4_lp_U7_S13: value is f32_gen4_dop_U6 & (f32_bits_22_23=0b11 | f32_bits_22_23=0b01)         [ value = (inst_start & ~3) + f32_gen4_dop_U6<<1;]                    						        { export *[ram]:4 value; }

f32_gen4_dbnz_S13: 	value is f32_gen4_dop_S_6_11 & f32_gen4_dop_S_5_0             [ value = (inst_start & ~3) + (f32_gen4_dop_S_6_11 << 7) + (f32_gen4_dop_S_5_0<<1);]                      { export *[ram]:4 value; }

f32_ext_dop_U12: value is f32_ext_dop_U_6_11 & f32_ext_dop_U_5_0                [ value = (f32_ext_dop_U_6_11 << 6) + f32_ext_dop_U_5_0;]                           { export *[const]:4 value; }


# ZZ (.zz) is data size 00 - word, 01 - byte, 10 - half word, 11 - raises an illegal instruction
# X (.x) sign extend: 0 if size is not word then data is zero extended, 1 if size is not word
# then data is sign extended.
# aa (.aa) adddests writeback mode
attach names [ f32_br1_branch_prediction_bit ] [ "" ".t" ];
attach names [ f32_ld_offset_X ]  [ "" ".x" ];
attach names [ f32_delay_bit f32_gen4_dop_N ]    [ "" ".d" ];
attach names [ f32_ld_offset_ZZ f32_st_offset_ZZ f32_gen4_dop_ZZ ] [ "" "b" "h" "d" ];

# Adddests writeback modes
# =====================================================================================================================
# AA bits  	| Adddests mode  	| Memory adddests used 						| Register value write-back
# =====================================================================================================================
#     00  	| No write-back 	| Reg + offset								| No write-back
#     01   	| .A or .AW     	| Reg + offset								| Reg + offset
#			|					|											| Register updated pre memory transaction
#     10   	| .AB           	| Reg										| Reg + offset
#			|					|											| Register updated post memory
#			|					|											| transaction
#     11   	| .AS				| Reg + (offset << scaling_shift)			| No write-back
#          	| Scaled, no		| Note that using the scaling adddests		|
#          	| write-back		| mode with 8-bit data size (LDB.AS or		|
#			|					| STB:AS) has undefined behavior and 		|
#			|					| must not be used.							|
#			|					| scaling_shift is based on the data 		|
#			|					| size mode, ZZ. For more information,		|
#			|					| see Table 7-13							|
#			|					| scaling_shift is defined in Table 7-11	|
attach names [ f32_ld_offset_aa f32_st_offset_aa f32_gen4_dop_aa ] [ "" ".a" ".ab" ".as" ];


attach names [ f32_st_offset_d f32_gen4_dop_D ] [ "" ".di" ];
attach names [ f32_bit_F ] [ "" ".f" ]; #any status flag updates still occur according to the set-flag directive or if flag setting is implicit in the instruction



# Condition Code Tests (reference Table 7-7 page 296)
# ======================================================================================================
# Code Q field 	| Mnemonic 		| Condition 								| Test
# ======================================================================================================
#	0x00 		| AL, RA 		| Always 									| 1
#	0x01 		| EQ, Z 		| Zero 										| Z
#	0x02 		| NE, NZ 		| Non-Zero 									| /Z
#	0x03 		| PL, P 		| Positive 									| /N
#	0x04 		| MI, N 		| Negative 									| N
#	0x05 		| CS, C,  LO 	| Carry set, lower than (unsigned) 			| C
#	0x06 		| CC, NC, HS 	| Carry clear, higher or same (unsigned) 	| /C
#	0x07 		| VS, V 		| Over-flow set 							| V
#	0x08 		| VC, NV 		| Over-flow clear 							| /V
#	0x09 		| GT 			| Greater than (signed) 					| (N and V and /Z) or (/N and /V and /Z)
#	0x0A 		| GE 			| Greater than or equal to (signed) 		| (N and V) or (/N and /V)
#	0x0B 		| LT 			| Less than (signed) 						| (N and /V) or (/N and V)
#	0x0C 		| LE 			| Less than or equal to (signed) 			| Z or (N and /V) or (/N and V)
#	0x0D 		| HI 			| Higher than (unsigned) 					| /C and /Z
#	0x0E 		| LS 			| Lower than or same (unsigned) 			| C or Z
#	0x0F 		| PNZ 			| Positive non-zero 						| /N and /Z

f32_cc: ""  	is f32_bits_22_23=0b00 | f32_bits_22_23=0b01 | f32_bits_22_23=0b10    	  { }
f32_cc: "al"  	is f32_bits_22_23=0b11 & f32_Q=0                                          { }
f32_cc: "eq"  	is f32_bits_22_23=0b11 & f32_Q=1                                          { if  (Z == 0) goto inst_next;	}
f32_cc: "ne"  	is f32_bits_22_23=0b11 & f32_Q=2                                          { if (!Z == 0) goto inst_next;	}
f32_cc: "p"  	is f32_bits_22_23=0b11 & f32_Q=3                                          { if (!N == 0) goto inst_next;	}
f32_cc: "n"  	is f32_bits_22_23=0b11 & f32_Q=4                                          { if  (N == 0) goto inst_next;	}
f32_cc: "lo"  	is f32_bits_22_23=0b11 & f32_Q=5                                          { if  (C == 0) goto inst_next;	}
f32_cc: "hs"  	is f32_bits_22_23=0b11 & f32_Q=6                                          { if (!C == 0) goto inst_next;	}
f32_cc: "vs"  	is f32_bits_22_23=0b11 & f32_Q=7                                          { if  (V == 0) goto inst_next;	}
f32_cc: "vc"  	is f32_bits_22_23=0b11 & f32_Q=8                                          { if (!V == 0) goto inst_next;	}
f32_cc: "gt"  	is f32_bits_22_23=0b11 & f32_Q=9                                          { if (((N && V && !Z) || (!N && !V && !Z)) == 0)  goto inst_next;	}
f32_cc: "ge"  	is f32_bits_22_23=0b11 & f32_Q=10                                         { if (((N && V) || (!N && !V))  == 0)             goto inst_next;	}
f32_cc: "lt"  	is f32_bits_22_23=0b11 & f32_Q=11                                         { if (((N && !V) || (!N && V)) == 0)              goto inst_next;	}
f32_cc: "le"  	is f32_bits_22_23=0b11 & f32_Q=12                                         { if ((Z || (N && !V) || (!N && V)) == 0)         goto inst_next;	}
f32_cc: "hi"  	is f32_bits_22_23=0b11 & f32_Q=13                                         { if ((!C && !Z) == 0)                            goto inst_next;	}
f32_cc: "ls"  	is f32_bits_22_23=0b11 & f32_Q=14                                         { if ((C || Z)   == 0)                            goto inst_next;	}
f32_cc: "pnz" 	is f32_bits_22_23=0b11 & f32_Q=15                                         { if ((!N && !Z)  == 0)                           goto inst_next;	}

f32_br0_cc: "al"  	is f32_Q=0   { tmp:1 = 1:1; 										export tmp;	}
f32_br0_cc: "eq"  	is f32_Q=1   { tmp:1 = Z; 											export tmp;	}
f32_br0_cc: "ne"  	is f32_Q=2   { tmp:1 = !Z; 											export tmp;	}
f32_br0_cc: "p"  	is f32_Q=3   { tmp:1 = !N; 											export tmp;	}
f32_br0_cc: "n"  	is f32_Q=4   { tmp:1 = N; 											export tmp;	}
f32_br0_cc: "lo"  	is f32_Q=5   { tmp:1 = C; 											export tmp;	}
f32_br0_cc: "hs"  	is f32_Q=6   { tmp:1 = !C;											export tmp;	}
f32_br0_cc: "vs"  	is f32_Q=7   { tmp:1 = V; 											export tmp;	}
f32_br0_cc: "vc"  	is f32_Q=8   { tmp:1 = !V; 											export tmp;	}
f32_br0_cc: "gt"  	is f32_Q=9   { tmp:1 = (N && V && !Z) || (!N && !V && !Z); 			export tmp;	}
f32_br0_cc: "ge"  	is f32_Q=10  { tmp:1 = (N && V) || (!N && !V); 						export tmp;	} 
f32_br0_cc: "lt"  	is f32_Q=11  { tmp:1 = (N && !V) || (!N && V); 						export tmp;	}
f32_br0_cc: "le"  	is f32_Q=12  { tmp:1 = Z || (N && !V) || (!N && V); 				export tmp;	}
f32_br0_cc: "hi"  	is f32_Q=13  { tmp:1 = !C && !Z; 									export tmp;	}
f32_br0_cc: "ls"  	is f32_Q=14  { tmp:1 = C || Z; 										export tmp;	}
f32_br0_cc: "pnz" 	is f32_Q=15  { tmp:1 = !N && !Z; 									export tmp;	}

ld_f32_gen4_update: "" is (f32_gen4_dop_aa=0b00) ... & f32_B_src & f32_C_src { }
ld_f32_gen4_update: "" is (f32_gen4_dop_aa=0b11) ... & f32_B_src & f32_C_src { }
ld_f32_gen4_update: "" is (f32_gen4_dop_aa=0b01) ... & f32_B_src & f32_C_src { 
  f32_B_src = f32_B_src + f32_C_src;
}

ld_f32_gen4_update: "" is (f32_gen4_dop_aa=0b10) ... & f32_B_src & f32_C_src { 
  f32_B_src = f32_B_src + f32_C_src;
}






ld_f32_gen4_load: "" is ((f32_gen4_dop_aa=0b00 | f32_gen4_dop_aa=0b01 | f32_gen4_dop_aa=0b11) &  f32_A_dst & f32_gen4_dop_ZZ=0b00 & f32_gen4_dop_X=0b0) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src + f32_gen4_C_aa_zz_src;
  local val:4 = *:4 addr;
  f32_A_dst = zext(val);
}

ld_f32_gen4_load: "" is (f32_gen4_dop_aa=0b10 &  f32_A_dst & f32_gen4_dop_ZZ=0b00 & f32_gen4_dop_X=0b0) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src;
  local val:4 = *:4 addr;
  f32_A_dst = zext(val);
}


ld_f32_gen4_load: "b" is ((f32_gen4_dop_aa=0b00 | f32_gen4_dop_aa=0b01 | f32_gen4_dop_aa=0b11) &  f32_A_dst & f32_gen4_dop_ZZ=0b01 & f32_gen4_dop_X=0b0) ... & f32_B_src & f32_gen4_C_aa_zz_src  {
  local addr:4 = f32_B_src + f32_gen4_C_aa_zz_src;
  local val:1 = *:1 addr;
  f32_A_dst = zext(val);
}

ld_f32_gen4_load: "b" is (f32_gen4_dop_aa=0b10 &  f32_A_dst & f32_gen4_dop_ZZ=0b01 & f32_gen4_dop_X=0b0) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src;
  local val:1 = *:1 addr;
  f32_A_dst = zext(val);
}


ld_f32_gen4_load: "h" is ((f32_gen4_dop_aa=0b00 | f32_gen4_dop_aa=0b01 | f32_gen4_dop_aa=0b11) &  f32_A_dst & f32_gen4_dop_ZZ=0b10 & f32_gen4_dop_X=0b0) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src + f32_gen4_C_aa_zz_src;
  local val:2 = *:2 addr;
  f32_A_dst = zext(val);
}

ld_f32_gen4_load: "h" is (f32_gen4_dop_aa=0b10 &  f32_A_dst & f32_gen4_dop_ZZ=0b10 & f32_gen4_dop_X=0b0) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src;
  local val:2 = *:2 addr;
  f32_A_dst = zext(val);
}


ld_f32_gen4_load: "" is ((f32_gen4_dop_aa=0b00 | f32_gen4_dop_aa=0b01 | f32_gen4_dop_aa=0b11) &  f32_A_dst & f32_gen4_dop_ZZ=0b00 & f32_gen4_dop_X=0b1) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src + f32_gen4_C_aa_zz_src;
  local val:4 = *:4 addr;
  f32_A_dst = sext(val);
}

ld_f32_gen4_load: "" is (f32_gen4_dop_aa=0b10 &  f32_A_dst & f32_gen4_dop_ZZ=0b00 & f32_gen4_dop_X=0b1) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src;
  local val:4 = *:4 addr;
  f32_A_dst = sext(val);
}


ld_f32_gen4_load: "b" is ((f32_gen4_dop_aa=0b00 | f32_gen4_dop_aa=0b01 | f32_gen4_dop_aa=0b11) &  f32_A_dst & f32_gen4_dop_ZZ=0b01 & f32_gen4_dop_X=0b1) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src + f32_gen4_C_aa_zz_src;
  local val:1 = *:1 addr;
  f32_A_dst = sext(val);
}

ld_f32_gen4_load: "b" is (f32_gen4_dop_aa=0b10 &  f32_A_dst & f32_gen4_dop_ZZ=0b01 & f32_gen4_dop_X=0b1) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src;
  local val:1 = *:1 addr;
  f32_A_dst = sext(val);
}


ld_f32_gen4_load: "h" is ((f32_gen4_dop_aa=0b00 | f32_gen4_dop_aa=0b01 | f32_gen4_dop_aa=0b11) &  f32_A_dst & f32_gen4_dop_ZZ=0b10 & f32_gen4_dop_X=0b1) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src + f32_gen4_C_aa_zz_src;
  local val:2 = *:2 addr;
  f32_A_dst = sext(val);
}

ld_f32_gen4_load: "h" is (f32_gen4_dop_aa=0b10 &  f32_A_dst & f32_gen4_dop_ZZ=0b10 & f32_gen4_dop_X=0b1) ... & f32_B_src & f32_gen4_C_aa_zz_src {
  local addr:4 = f32_B_src;
  local val:2 = *:2 addr;
  f32_A_dst = sext(val);
}

set_rules: "eq" is (f32_gen4_dop_i=0b111000 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src ==  f32_B_src);}
set_rules: "ne" is (f32_gen4_dop_i=0b111001 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src !=  f32_B_src);}
set_rules: "lt" is (f32_gen4_dop_i=0b111010 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src s<  f32_B_src);}
set_rules: "ge" is (f32_gen4_dop_i=0b111011 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src s>= f32_B_src);}
set_rules: "lo" is (f32_gen4_dop_i=0b111100 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src <   f32_B_src);}
set_rules: "hs" is (f32_gen4_dop_i=0b111101 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src >=  f32_B_src);}
set_rules: "le" is (f32_gen4_dop_i=0b111110 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src s<= f32_B_src);}
set_rules: "gt" is (f32_gen4_dop_i=0b111111 & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src { f32_A_B_dst = zext(f32_C_U6_S12_src s>  f32_B_src);}

set_rules_flags: ".f" is (f32_gen4_dop_i=0b111111) ... & f32_C_U6_S12_src & f32_B_src { 
	Z = f32_C_U6_S12_src == f32_B_src;
	N = (f32_B_src - f32_C_U6_S12_src) s< 0:4;
	C = f32_B_src < f32_C_U6_S12_src;
	V = scarry(f32_B_src, f32_C_U6_S12_src);
}

gen4_f32_A_B_dst_ZN: ""   is (f32_A_B_dst & f32_bit_F=0b0) {}
gen4_f32_A_B_dst_ZN: ".f" is (f32_A_B_dst & f32_bit_F=0b1) {UPDATE_FLAGS_ZN(f32_A_B_dst);}

gen4_f32_B_dst_ZN: ""   is (f32_B_dst & f32_bit_F=0b0) {}
gen4_f32_B_dst_ZN: ".f" is (f32_B_dst & f32_bit_F=0b1) {UPDATE_FLAGS_ZN(f32_B_dst);}








# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_GEN_OP INSTRUCTIONS
# ***********************************************************************************************
# ***********************************************************************************************

with : F16_MAJOR_OPCODE=$(F16_GEN_OP) {
  :abs_s  f16_b, f16_c            is f16_gen_op_U=0b10001 & f16_b & f16_c  { 
    local acond:1 = (f16_c s< 0:4);
    f16_b = f16_c*zext(acond == 0)-f16_c*zext(acond != 0);
  }

  :add1_s f16_b, f16_b_cp, f16_c  is f16_gen_op_U=0b10100 & f16_b & f16_b_cp & f16_c { 
    f16_b = f16_b_cp + (f16_c << 1);
  }

  :add2_s f16_b, f16_b_cp, f16_c  is f16_gen_op_U=0b10101 & f16_b & f16_b_cp & f16_c { 
    f16_b = f16_b_cp + (f16_c << 2);
  }

  :add3_s f16_b, f16_b_cp, f16_c  is f16_gen_op_U=0b10110 & f16_b & f16_b_cp & f16_c { 
    f16_b = f16_b_cp + (f16_c << 3);
  }

  :and_s  f16_b, f16_b_cp, f16_c  is f16_gen_op_U=0b00100 & f16_b & f16_b_cp & f16_c { 
    f16_b = f16_b_cp & f16_c;
  }

  :add_s f16_b, f16_c             is f16_gen_op_U=0b11011 & f16_b & f16_c { 
    f16_b = f16_b + f16_c;
  }

  :asl_s f16_b, f16_b_cp, f16_c   is f16_gen_op_U=0b11000 & f16_b & f16_b_cp & f16_c { 
    f16_b = f16_b_cp << f16_c;
  }

  :asr_s f16_b, f16_c, 1          is f16_gen_op_U=0b11100 & f16_b & f16_c { 
    f16_b = f16_c s>> 1;
  }

  :asr_s f16_b, f16_b_cp, f16_c   is f16_gen_op_U=0b11010 & f16_b & f16_b_cp & f16_c { 
    f16_b = f16_b_cp >> f16_c;
  }

  :bic_s f16_b, f16_b_cp, f16_c   is f16_gen_op_U=0b00110 & f16_b & f16_b_cp & f16_c { 
    f16_b = f16_b_cp & ~f16_c;
  }
}

# ---------------------------------------------------------------------
# POTENTIAL PROBLEM FOR ARCV2 BREAK and INST_START ARE NOT IMPLEMENTED
# ---------------------------------------------------------------------
:brk_s                          is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b11111 & f16_b=0b111 & f16_c=0b111 { 
  #brk();
  #goto inst_start;
}

:extb_s f16_b, f16_c            is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b01111 & f16_b & f16_c { 
  f16_b = f16_c & 0x000000FF:4;
}

:exth_s f16_b, f16_c            is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b10000 & f16_b & f16_c { 
  f16_b = f16_c & 0x0000FFFF:4;
}



with : F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b00000 {

  :j_s [f16_b]                        is f16_b & f16_c=0b000 { 
    goto [f16_b];
  }

  :j_s.d [f16_b]                      is f16_b & f16_c=0b001 { 
    delayslot(1);
    goto [f16_b];
  }

  with : f16_c=0b111 {
    :j_s [blink]                      is f16_b=0b110 & blink  { 
      return [blink];
    }

    :j_s.d [blink]                    is f16_b=0b111 & blink { 
      delayslot(1);
      return [blink];
    }

    :jeq_s [blink]                    is f16_b=0b100 & blink { 
      if (!Z) goto inst_next;
      return [blink];
    }

    :jne_s [blink]                    is f16_b=0b101 & blink { 
      if (Z) goto inst_next;
      return [blink];
    }
  }

  :jl_s [f16_b]                     is f16_b & f16_c=0b010 { 
    blink = inst_next;
    call [f16_b];
  }

  :jl_s.d [f16_b]                   is f16_b & f16_c=0b011 { 
    blink = inst_next;
    delayslot(1);
    call [f16_b];
  }
}

:lsr_s f16_b, f16_c, 1          is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b11101 & f16_b & f16_c { 
  f16_b = f16_c >> 1;
}   

:lsr_s f16_b, f16_b_cp, f16_c   is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b11001 & f16_b & f16_b_cp & f16_c { 
  f16_b = f16_b_cp >> (f16_c[0,5]);
}   

:mpy_s f16_b, f16_b_cp, f16_c   is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b01100 & f16_b & f16_b_cp & f16_c { 
  local val_b:8 = sext(f16_b);
  local val_c:8 = sext(f16_c);

  local mult:8  = val_b * val_c;

  f16_b = mult(4);
}

:mpyuw_s f16_b, f16_b_cp, f16_c is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b01010 & f16_b & f16_b_cp & f16_c { 
  local val_b:8 = zext(f16_b);
  local val_c:8 = zext(f16_c);

  local mult:8  = val_b * val_c;

  f16_b = mult(4);
}

:mpyw_s f16_b, f16_b_cp, f16_c  is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b01001 & f16_b & f16_b_cp & f16_c { 
  local val_b:8 = sext(f16_b);
  local val_c:8 = sext(f16_c);

  local mult:8  = val_b * val_c;

  f16_b = mult(4);
}

:neg_s f16_b, f16_c             is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b10011 & f16_b & f16_c { 
  f16_b = -f16_c;
}   

:nop_s                          is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b00000 & f16_b=0b000 & f16_c=0b111 { }   

:not_s f16_b, f16_c             is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b10010 & f16_b & f16_c { 
  f16_b = ~f16_c;
} 

:or_s f16_b, f16_b_cp, f16_c    is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b00101 & f16_b & f16_b_cp & f16_c { 
  f16_b = f16_b_cp | f16_c;
} 

:sexb_s f16_b, f16_c            is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b01101 & f16_b & f16_c { 
  f16_b = sext(f16_c:1);
} 

:sub_s.ne f16_b, f16_b_cp       is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b00000 & f16_b & f16_b_cp & f16_c=0b110 { 
  if (Z) goto inst_next;
  f16_b = 0;
} 

:sub_s.ne f16_b, f16_b_cp, f16_c is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b00010 & f16_b & f16_b_cp & f16_c { 
  f16_b = f16_b_cp - f16_c;
} 

# ---------------------------------------------------------------------
# POTENTIAL PROBLEM: SWI and TRAP_S are not implemented
# ---------------------------------------------------------------------
:trap f16_gen_op_u6 is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_u6 & f16_gen_op_U=0b11110 { 
}

:tst_s f16_b, f16_c             is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b01011 & f16_b & f16_c { 
  local alu:4 = f16_b & f16_c;

  UPDATE_FLAGS_ZN(alu);
} 

:unimp_s                        is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b00000 & f16_b=0b001 & f16_c=0b111 { 
  IE = 0;
  U = 0;
  AE = 1;
} 

:xor_s f16_b, f16_b_cp, f16_c   is F16_MAJOR_OPCODE=$(F16_GEN_OP) & f16_gen_op_U=0b00111 & f16_b & f16_b_cp & f16_c { 
  f16_b = f16_b_cp ^ f16_c;
}



# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_COMPACT INSTRUCTIONS
# ***********************************************************************************************
# ***********************************************************************************************

# R30 (f16_G_g=0b11110) is actually a long-immediate data operand when used as the source 
# register, and a null destination register
# As well pages 295, 641 in the reference
# When a destination register field contains 62, the dest of the instruction is discarded and no 
# destination register is updated. Any status flag updates still occur according to the set-flags 
# directive (.F) or if flag setting is implicit in the instruction.
# If the long immediate indicator is used in both a source and the destination operand, a long 
# immediate value is used as the source operand and the dest is discarded as expected.
# Instructions encoded in 16-bit formats do not offer the option to set flags. However, flag updates 
# are performed implicitly by a small number of 16-bit encoded instructions where the flag update is 
# the primary dest. This includes BTST_S, CMP_S, and TST_S.


:mov_s f16_G_g, f16_H_h                       is F16_MAJOR_OPCODE=$(F16_COMPACT) & f16_bit2=0b0 & f16_G_g & f16_H_h { 
  f16_G_g = f16_H_h;
} 

:mov_s f16_G_g, limm                          is F16_MAJOR_OPCODE=$(F16_COMPACT) & f16_bit2=0b0 & f16_G_g & f16_H=0b11 & f16_h=0b110; limm { 
  f16_G_g = limm;
} 

:mov_s 0, f16_H_h                             is F16_MAJOR_OPCODE=$(F16_COMPACT) & f16_bit2=0b0 & f16_G=0b11 & f16_g=0b110 & f16_H_h; limm { } 

:mov_s 0, limm                                is F16_MAJOR_OPCODE=$(F16_COMPACT) & f16_bit2=0b0 & f16_G=0b11 & f16_g=0b110 & f16_H=0b11 & f16_h=0b110; limm { } 

:ld_s f16_compact_r, [f16_H_h, f16_compact_U] is F16_MAJOR_OPCODE=$(F16_COMPACT) & f16_bit2=0b1 & f16_H_h & f16_compact_U & f16_compact_r { 
  local addr:4 = f16_H_h+f16_compact_U;
  f16_compact_r = *[ram]:4 addr;
} 


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_LD_ADD_SUB 0b01001
# ***********************************************************************************************
# ***********************************************************************************************
with : F16_MAJOR_OPCODE=$(F16_LD_ADD_SUB) {
  :add_s f16_ld_add_sub_r, f16_b, f16_ld_add_sub_U  is f16_b & f16_ld_add_sub_r & f16_ld_add_sub_U & f16_bit3=0b1 {
    f16_ld_add_sub_r = f16_b + f16_ld_add_sub_U;
  }

  :ld_s.as f16_a, [f16_b, f16_c]                    is f16_a & f16_G=0b00 & f16_b & f16_c { 
    local addr:4 = f16_b+f16_c;
    f16_a = *[ram]:4 addr;
  } 

  :sub_s f16_a, f16_b, f16_c                        is f16_a & f16_G=0b10 & f16_b & f16_c { 
    f16_a = f16_b - f16_c;
  } 
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_LD_ST_1
# ***********************************************************************************************
# ***********************************************************************************************
:ld_s r1, [gp, f16_ld_st_1_S]   is F16_MAJOR_OPCODE=$(F16_LD_ST_1) & f16_ld_st_1_S & f16_G=0b00 & r1 & gp { 
  local addr:4 = gp + f16_ld_st_1_S;
  r1 = *[ram]:4 addr;
} 

:ldi_s f16_b, f16_ld_st_1_U     is F16_MAJOR_OPCODE=$(F16_LD_ST_1) & f16_b & f16_bit3=0b1 & f16_ld_st_1_U { 
  #f16_b = *[AUX_REGS_BASE]:4 (f16_ld_st_1_U << 2);
} 

:st_s r0, [gp, f16_ld_st_1_S]   is F16_MAJOR_OPCODE=$(F16_LD_ST_1) & f16_ld_st_1_S & f16_G=0b10 & r0 & gp { 
  local addr:4 = gp + f16_ld_st_1_S;
  *addr = r0;
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_JLI_EI
# ***********************************************************************************************
# ***********************************************************************************************
:ei_s f16_fli_ei_U_0_9 is F16_MAJOR_OPCODE=$(F16_JLI_EI) & f16_fli_ei_U_0_9 & f16_bit10=0b1 {
  local addr:4 = EI_BASE + f16_fli_ei_U_0_9 << 2;
  BTA = inst_next;
  ES  = 1;
  goto [addr];
}

:jli_s f16_fli_ei_U_0_9 is F16_MAJOR_OPCODE=$(F16_JLI_EI) & f16_fli_ei_U_0_9 & f16_bit10=0b0 {
  local addr:4 = JLI_BASE + f16_fli_ei_U_0_9 << 2;
  blink = inst_next;
  goto [addr];
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_LD_ADD_RR 0b01100
# ***********************************************************************************************
# ***********************************************************************************************
with : F16_MAJOR_OPCODE=$(F16_LD_ADD_RR) {
  :add_s f16_a, f16_b, f16_c      is f16_i = 0b11 & f16_a & f16_b & f16_c {
    f16_a = f16_b + f16_c;
  }

  :ld_s f16_a, [f16_b, f16_c]     is f16_i = 0b00 & f16_a & f16_b & f16_c {
    local addr:4 = f16_b + f16_c;
    f16_a = *:4 addr;
  }

  :ldb_s f16_a, [f16_b, f16_c]    is f16_i = 0b01 & f16_a & f16_b & f16_c {
    local addr:4 = f16_b + f16_c;
    f16_a = zext(*:1 addr);
  }

  :ldh_s f16_a, [f16_b, f16_c]    is f16_i = 0b10 & f16_a & f16_b & f16_c {
    local addr:4 = f16_b + f16_c;
    f16_a = zext(*:2 addr);
  }
}
# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_ADD_IMM 0b01101
# ***********************************************************************************************
# ***********************************************************************************************
with : F16_MAJOR_OPCODE=$(F16_ADD_IMM) {
  :add_s f16_c, f16_b, f16_add_imm_U  is f16_i = 0b00 & f16_b & f16_c & f16_add_imm_U {
    f16_c = f16_b + f16_add_imm_U;
  }

  :asl_s f16_c, f16_b, f16_add_imm_U  is f16_i = 0b10 & f16_b & f16_c & f16_add_imm_U {
    f16_c = f16_b << f16_add_imm_U;
  }

  :asr_s f16_c, f16_b, f16_add_imm_U  is f16_i = 0b11 & f16_b & f16_c & f16_add_imm_U {
    f16_c = f16_b s>> f16_add_imm_U;
  }

  :sub_s f16_c, f16_b, f16_add_imm_U  is f16_i = 0b01 & f16_b & f16_c & f16_add_imm_U {
    f16_c = f16_b - f16_add_imm_U;
  }
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_OP_HREG 0b01110
# ***********************************************************************************************
# ***********************************************************************************************
:add_s f16_b, f16_b_cp, f16_op_hreg_H_h                     is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b00 & f16_bit2=0b0 & f16_b & f16_b_cp & f16_op_hreg_H_h {
  f16_b = f16_b_cp + f16_op_hreg_H_h;
}

:add_s f16_b, f16_b_cp, limm                                is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b00 & f16_bit2=0b0 & f16_op_hreg_H=0b11 & f16_op_hreg_h=0b110 & f16_b & f16_b_cp; limm {
  f16_b = f16_b_cp + limm;
}

:add_s f16_op_hreg_H_h, f16_op_hreg_H_h_cp, f16_op_hreg_S   is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b00 & f16_bit2=0b1 & f16_op_hreg_H_h & f16_op_hreg_H_h_cp & f16_op_hreg_S {
  f16_op_hreg_H_h = f16_op_hreg_H_h_cp + f16_op_hreg_S;
}

:add_s 0, limm, f16_op_hreg_S                               is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b00 & f16_bit2=0b1 & f16_op_hreg_H=0b11 & f16_op_hreg_h=0b110 & f16_b & f16_b_cp & f16_op_hreg_S; limm {
  
}

:cmp_s f16_b, f16_op_hreg_H_h                               is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b10 & f16_bit2=0b0 & f16_b & f16_op_hreg_H_h {
  local dest:4 = f16_b - f16_op_hreg_H_h;
  
  UPDATE_FLAGS_ZN(dest);
  
  C = (dest s< 0:4);
  V = sborrow(f16_b, f16_op_hreg_H_h);
}

:cmp_s f16_b, limm                               			is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b10 & f16_bit2=0b0 & f16_b & f16_op_hreg_H=0b11 & f16_op_hreg_h=0b110; limm {
  local dest:4 = f16_b - limm;
  
  UPDATE_FLAGS_ZN(dest);
  
  C = (dest s< 0:4);
  V = sborrow(f16_b, limm);
}

:cmp_s f16_op_hreg_H_h, f16_op_hreg_S                       is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b10 & f16_bit2=0b1 & f16_op_hreg_S & f16_op_hreg_H_h {
  local dest:4 = f16_op_hreg_H_h - f16_op_hreg_S;
  
  UPDATE_FLAGS_ZN(dest);
  
  C = (dest s< 0:4);
  V = sborrow(f16_op_hreg_H_h, f16_op_hreg_S);
}

:cmp_s limm, f16_op_hreg_S                       			is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b10 & f16_bit2=0b1 & f16_op_hreg_S & f16_op_hreg_H=0b11 & f16_op_hreg_h=0b110; limm {
  local dest:4 = limm - f16_op_hreg_S;
  
  UPDATE_FLAGS_ZN(dest);
  
  C = (dest s< 0:4);
  V = sborrow(limm, f16_op_hreg_S);
}

:mov_s f16_op_hreg_H_h, f16_op_hreg_S                       is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b01 & f16_bit2=0b1 & f16_op_hreg_S & f16_op_hreg_H_h {
  f16_op_hreg_H_h = f16_op_hreg_S;
}

:mov_s 0, f16_op_hreg_S                                     is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b01 & f16_bit2=0b1 & f16_op_hreg_S & f16_op_hreg_H=0b11 & f16_op_hreg_h=0b110 {

}

:mov_s.ne f16_b, f16_op_hreg_H_h                            is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b11 & f16_bit2=0b1 & f16_b & f16_op_hreg_H_h {
  f16_b = f16_op_hreg_H_h;
}

:mov_s.ne f16_b, limm                                       is F16_MAJOR_OPCODE=$(F16_OP_HREG) & f16_i = 0b11 & f16_bit2=0b1 & f16_b & f16_op_hreg_H=0b11 & f16_op_hreg_h=0b110; limm {
  f16_b = limm;
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_LD_WORD 0b01110, F16_LD_BYTE  0b10001, F16_LD_HALF 0b10010, 
#             F16_LDX_HALF    0b10011, F16_ST_WORD  0b10100, F16_ST_BYTE 0b10101, 
#             F16_ST_HALF     0b10110
# ***********************************************************************************************
# ***********************************************************************************************
:ld_s f16_c, [f16_b, f16_ld_word_u7]      is F16_MAJOR_OPCODE=$(F16_LD_WORD) & f16_ld_word_u7 & f16_b & f16_c {
  local addr:4 = f16_b + f16_ld_word_u7;
  f16_c = *:4 addr;
}

:ldb_s f16_c, [f16_b, f16_ld_word_u5]      is F16_MAJOR_OPCODE=$(F16_LD_BYTE) & f16_ld_word_u5 & f16_b & f16_c {
  local addr:4 = f16_b + f16_ld_word_u5;
  f16_c = zext(*:1 addr);
}

:ldh_s f16_c, [f16_b, f16_ld_word_u6]     is F16_MAJOR_OPCODE=$(F16_LD_HALF) & f16_ld_word_u6 & f16_b & f16_c {
  local addr:4 = f16_b + f16_ld_word_u6;
  f16_c = zext(*:2 addr);
}

:ldh_s.x f16_c, [f16_b, f16_ld_word_u6]   is F16_MAJOR_OPCODE=$(F16_LDX_HALF) & f16_ld_word_u6 & f16_b & f16_c {
  local addr:4 = f16_b + f16_ld_word_u6;
  f16_c = zext(*:2 addr);
}

:st_s f16_c, [f16_b, f16_ld_word_u7]      is F16_MAJOR_OPCODE=$(F16_ST_WORD) & f16_ld_word_u7 & f16_b & f16_c {
  local addr:4 = f16_b + f16_ld_word_u7;
  *:4 addr = f16_c;
}

:stb_s f16_c, [f16_b, f16_ld_word_u5]      is F16_MAJOR_OPCODE=$(F16_ST_BYTE) & f16_ld_word_u5 & f16_b & f16_c {
  local addr:4 = f16_b + f16_ld_word_u5;
  *:4 addr = f16_c:1;
}

:sth_s f16_c, [f16_b, f16_ld_word_u6]     is F16_MAJOR_OPCODE=$(F16_ST_HALF) & f16_ld_word_u6 & f16_b & f16_c {
  local addr:4 = f16_b + f16_ld_word_u6;
  *:4 addr = f16_c:2;
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_SH_SUB_BIT 0b10111
# ***********************************************************************************************
# ***********************************************************************************************
:asl_s f16_b, f16_b_cp, f16_sh_sub_bit_U    is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b000 & f16_b & f16_b_cp & f16_sh_sub_bit_U {
  f16_b = f16_b_cp << f16_sh_sub_bit_U;
}

:asr_s f16_b, f16_b_cp, f16_sh_sub_bit_U    is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b010 & f16_b & f16_b_cp & f16_sh_sub_bit_U { 
  f16_b = f16_b_cp s>> f16_sh_sub_bit_U;
}

:bclr_s f16_b, f16_b_cp, f16_sh_sub_bit_U   is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b101 & f16_b & f16_b_cp & f16_sh_sub_bit_U { 
  f16_b = f16_b_cp & ~(1:4 << f16_sh_sub_bit_U);
}

:bmsk_s f16_b, f16_b_cp, f16_sh_sub_bit_U   is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b110 & f16_b & f16_b_cp & f16_sh_sub_bit_U { 
  f16_b = f16_b_cp & ((1:4 << (f16_sh_sub_bit_U+1)) -1 );
}

:bset_s f16_b, f16_b_cp, f16_sh_sub_bit_U   is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b100 & f16_b & f16_b_cp & f16_sh_sub_bit_U { 
  f16_b = f16_b_cp | (1:4 << f16_sh_sub_bit_U);
}

:btst_s f16_b, f16_sh_sub_bit_U             is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b111 & f16_b & f16_sh_sub_bit_U { 
  local alu = f16_b | (1:4 << f16_sh_sub_bit_U);
  UPDATE_FLAGS_ZN(alu);
}

:lsr_s f16_b, f16_b_cp, f16_sh_sub_bit_U   is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b001 & f16_b & f16_b_cp & f16_sh_sub_bit_U { 
  f16_b = f16_b_cp >> (f16_sh_sub_bit_U);
}

:sub_s f16_b, f16_b_cp, f16_sh_sub_bit_U    is F16_MAJOR_OPCODE=$(F16_SH_SUB_BIT) & f16_sh_sub_bit_i = 0b011 & f16_b & f16_b_cp & f16_sh_sub_bit_U { 
  f16_b = f16_b_cp - f16_sh_sub_bit_U;
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_SP_OPS 0b11000
# ***********************************************************************************************
# ***********************************************************************************************
with : F16_MAJOR_OPCODE=$(F16_SP_OPS)  {
  # ADD_S b, sp, u7   11000bbb100uuuuu
  :add_s f16_b, sp, f16_sp_ops_simple_u7    is f16_sp_ops_i = 0b100 & f16_sp_ops_simple_u7 & sp & f16_b {
    f16_b = sp + f16_sp_ops_simple_u7;
  }

  # ADD_S SP, SP, u7  11000000101uuuuu
  :add_s sp, f16_sp_ops_simple_u7           is f16_sp_ops_i = 0b101 & f16_sp_ops_simple_u7 & sp & f16_b=0b000 {
    sp = sp + f16_sp_ops_simple_u7;
  }
}

:enter_s {enter_s_regs^f16_sp_ops_u_4_5} is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_bit10=0b0 & f16_sp_ops_i=0b111 & f16_bit0=0b0 & f16_sp_ops_u_0_3 & f16_sp_ops_u_4_5 & enter_s_regs{
  build enter_s_regs;
}

:ld_s f16_b, [sp, U7] is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b000 & f16_b & sp & f16_sp_ops_u_0_4 [U7 = f16_sp_ops_u_0_4 << 2; ]{
  local addr:4 = sp + (f16_sp_ops_u_0_4 << 2);
  f16_b = *:4 addr;
}

:ldb_s f16_b, [sp, U7] is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b001 & f16_b & sp & f16_sp_ops_u_0_4 [U7 = f16_sp_ops_u_0_4 << 2; ]{
  local addr:4 = sp + (f16_sp_ops_u_0_4 << 2);
  f16_b = zext(*:1 addr);
}

:leave_s {f16_sp_ops_u_0_3^f16_sp_ops_u_4_6} is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i=0b110 & f16_bit0=0b0 & f16_sp_ops_u_0_3 & f16_sp_ops_u_4_6 & leave_s_regs {
  build leave_s_regs;
}

:pop_s f16_b            is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b110 & f16_b & f16_sp_ops_u_0_4=0b00001 {
  pop(f16_b);
}

:pop_s blink            is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b110 & f16_b & f16_sp_ops_u_0_4=0b10001 & blink {
  pop(blink);
}

:push_s f16_b           is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b111 & f16_b & f16_sp_ops_u_0_4=0b00001 {
  push4(f16_b);
}

:push_s blink           is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b111 & f16_b & f16_sp_ops_u_0_4=0b10001 & blink {
  push4(blink);
}

:st_s f16_b, [sp, U7]   is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b010 & f16_b & sp & f16_sp_ops_u_0_4 [U7 = f16_sp_ops_u_0_4 << 2; ]{
  local addr:4 = sp + (f16_sp_ops_u_0_4 << 2);
  *:4 addr = f16_b;
}

:stb_s f16_b, [sp, U7]  is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b011 & f16_b & sp & f16_sp_ops_u_0_4 [U7 = f16_sp_ops_u_0_4 << 2; ]{
  local addr:4 = sp + (f16_sp_ops_u_0_4 << 2);
  *:4 addr = f16_b:1;
}

:sub_s sp, U7           is F16_MAJOR_OPCODE=$(F16_SP_OPS) & f16_sp_ops_i = 0b101 & f16_b=0b001 & sp & f16_sp_ops_u_0_4 [U7 = f16_sp_ops_u_0_4 << 2; ]{
  sp = sp - (f16_sp_ops_u_0_4 << 2);
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_GP_LD_ADD 0b11001
# ***********************************************************************************************
# ***********************************************************************************************
:add_s r0, gp, S11                  is F16_MAJOR_OPCODE=$(F16_GP_LD_ADD) & f16_gp_add_load_i = 0b11 & f16_gp_add_load_S & gp & r0 [S11 = f16_gp_add_load_S << 2; ]{
  r0 = gp + (f16_gp_add_load_S << 2);
}

:ld_s r0, [gp, S11]                 is F16_MAJOR_OPCODE=$(F16_GP_LD_ADD) & f16_gp_add_load_i = 0b00 & f16_gp_add_load_S & gp & r0 [S11 = f16_gp_add_load_S << 2; ]{
  local addr:4 = gp + (f16_gp_add_load_S << 2);
  r0 = *:4 addr;
}

:ldb_s r0, [gp, f16_gp_add_load_S]  is F16_MAJOR_OPCODE=$(F16_GP_LD_ADD) & f16_gp_add_load_i = 0b01 & f16_gp_add_load_S & gp & r0 {
  local addr:4 = gp + f16_gp_add_load_S;
  r0 = zext(*:1 addr);
}

:ldh_s r0, [gp, S10]                is F16_MAJOR_OPCODE=$(F16_GP_LD_ADD) & f16_gp_add_load_i = 0b10 & f16_gp_add_load_S & gp & r0 [S10 = f16_gp_add_load_S << 1; ]{
  local addr:4 = gp + (f16_gp_add_load_S << 1);
  r0 = zext(*:2 addr);
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_PCL_LD
# ***********************************************************************************************
# ***********************************************************************************************
:ld_s f16_b, [pcl, U10] is F16_MAJOR_OPCODE=$(F16_PCL_LD) & f16_b & f16_pcl_ld_U & pcl [U10 = f16_pcl_ld_U << 1; ]{
  local addr:4 = pcl + (f16_pcl_ld_U << 1);
  f16_b = *:4 addr;
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_MV_IMM
# ***********************************************************************************************
# ***********************************************************************************************
:mov_s f16_b, f16_mv_imm_U is F16_MAJOR_OPCODE=$(F16_MV_IMM) & f16_b & f16_mv_imm_U {
  f16_b = f16_mv_imm_U;
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_OP_IMM 0b11100
# ***********************************************************************************************
# ***********************************************************************************************
with : F16_MAJOR_OPCODE=$(F16_OP_IMM) {
  :add_s f16_b, f16_b_cp, f16_op_imm_U  is f16_bit7=0b0 & f16_b & f16_op_imm_U & f16_b_cp  {
    f16_b = f16_b_cp + f16_op_imm_U;
  }

  :cmp_s f16_b, f16_op_imm_U            is f16_bit7=0b1 & f16_b & f16_op_imm_U {
    local dest:4 = f16_b - f16_op_imm_U;

    UPDATE_FLAGS_ZN(dest);
    C = (dest s< 0:4);
    V = sborrow(f16_b, f16_op_imm_U);
  }
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_BCC_REG
# ***********************************************************************************************
# ***********************************************************************************************
:brne_s f16_b, 0, f16_bcc_reg_S8 is F16_MAJOR_OPCODE=$(F16_BCC_REG) & f16_b & f16_bit7=0b1 & f16_bcc_reg_S8 {
  if (f16_b != 0) goto f16_bcc_reg_S8;
}

:breq_s f16_b, 0, f16_bcc_reg_S8 is F16_MAJOR_OPCODE=$(F16_BCC_REG) & f16_b & f16_bit7=0b0 & f16_bcc_reg_S8 {
  if (f16_b == 0) goto f16_bcc_reg_S8;
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_BCC
# ***********************************************************************************************
# ***********************************************************************************************
:b_s f16_bcc_s10    is F16_MAJOR_OPCODE=$(F16_BCC) & f16_bit10=0b0 & f16_bit9=0b0 & f16_bcc_s10 {
  goto f16_bcc_s10;
}

:beq_s f16_bcc_s10  is F16_MAJOR_OPCODE=$(F16_BCC) & f16_bit10=0b0 & f16_bit9=0b1 & f16_bcc_s10 {
  if (Z) goto f16_bcc_s10;
}

:bne_s f16_bcc_s10  is F16_MAJOR_OPCODE=$(F16_BCC) & f16_bit10=0b1 & f16_bit9=0b0 & f16_bcc_s10 {
  if (!Z) goto f16_bcc_s10;
}

with : F16_MAJOR_OPCODE=$(F16_BCC) & f16_bit9=0b1 & f16_bit10=0b1 {

  :bgt_s f16_bcc_s7   is f16_bcc_reg_i=0b000 & f16_bcc_s7 {
    if (!Z && (V == N)) goto f16_bcc_s7;
  }

  :bge_s f16_bcc_s7   is f16_bcc_reg_i=0b001 & f16_bcc_s7{
    if (V == N) goto f16_bcc_s7;
  }

  :blt_s f16_bcc_s7   is f16_bcc_reg_i=0b010 & f16_bcc_s7{
    if (V != N) goto f16_bcc_s7;
  }

  :ble_s f16_bcc_s7   is f16_bcc_reg_i=0b011 & f16_bcc_s7{
    if (Z || (V != N)) goto f16_bcc_s7;
  }

  :bhi_s f16_bcc_s7   is f16_bcc_reg_i=0b100 & f16_bcc_s7{
    if (!C && !Z) goto f16_bcc_s7;
  }

  :bhs_s f16_bcc_s7   is f16_bcc_reg_i=0b101 & f16_bcc_s7{
    if (!C) goto f16_bcc_s7;
  }

  :blo_s f16_bcc_s7   is f16_bcc_reg_i=0b110 & f16_bcc_s7{
    if (C) goto f16_bcc_s7;
  }

  :bls_s f16_bcc_s7   is f16_bcc_reg_i=0b111 & f16_bcc_s7 {
    if (C || Z) goto f16_bcc_s7;
  }
}


# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F16_BL
# ***********************************************************************************************
# ***********************************************************************************************
:bl_s f16_bl_s13 is F16_MAJOR_OPCODE=$(F16_BL) & f16_bl_s13 {
  blink = inst_next;
  call f16_bl_s13;
}



# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F32_BR0 = 0b00000
# ***********************************************************************************************
# ***********************************************************************************************

# --------------------------------------------- B ---------------------------------------------
#B<.d> s25 (unconditional branch far)
#B<.d> s25 00000ssssssssss1 SSSSSSSSSSNRtttt

:b f32_br0_S25              	is F32_MAJOR_OPCODE=$(F32_BR0) & f32_bit5=0b0 & f32_bit16=0b1 & f32_br0_S25  {
	goto f32_br0_S25;
}

:b.d f32_br0_S25          	is F32_MAJOR_OPCODE=$(F32_BR0) & f32_bit5=0b1 & f32_bit16=0b1 & f32_br0_S25 & f32_bit4  {
  delayslot(1);
  goto f32_br0_S25;
}

# --------------------------------------------- Bcc ---------------------------------------------
#Bcc<.d>   s21 (branch if condition is true)
#B<cc><.d> s21 00000ssssssssss0 SSSSSSSSSSNQQQQQ

:b^f32_br0_cc f32_br0_S21       is F32_MAJOR_OPCODE=$(F32_BR0) & f32_bit5=0b0 & f32_bit16=0b0 & f32_br0_S21 & f32_br0_cc {      
  if (f32_br0_cc == 1:1) goto f32_br0_S21;
}

:b^f32_br0_cc^".d" f32_br0_S21  is F32_MAJOR_OPCODE=$(F32_BR0) & f32_bit5=0b1 & f32_bit16=0b0 & f32_br0_S21 & f32_br0_cc {      
  delayslot(1);
  if (f32_br0_cc == 1:1) goto f32_br0_S21; 
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F32_BR1 = 0b00001
# ***********************************************************************************************
# ***********************************************************************************************

# --------------------------------------------- BBIT0 ---------------------------------------------
#BBIT0<.d><.T> b,c,s9  (branch if bit c in reg b is clear)
#BBIT0<.d><.T> b,u6,s9 (branch if bit u6 in reg b is clear)

#BBIT0<.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y110
#BBIT0<.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y110

:bbit0^f32_br1_branch_prediction_bit   		f32_B_dst, f32_br1_C_U6_src, f32_br1_S9   	is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b110 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_B_dst & f32_br1_S9) ... & f32_br1_C_U6_src {
  if ((f32_B_dst & (1:4 << f32_br1_C_U6_src[0,5])) == 0:4) goto f32_br1_S9;
}

:bbit0.d^f32_br1_branch_prediction_bit 	f32_B_dst, f32_br1_C_U6_src, f32_br1_S9 	is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b110 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_B_dst & f32_br1_S9) ... & f32_br1_C_U6_src {
  
  delayslot(1);
  if ((f32_B_dst & (1:4 << f32_br1_C_U6_src[0,5])) == 0:4) goto f32_br1_S9;
}

# --------------------------------------------- BBIT1 ---------------------------------------------
#BBIT1<.d><.T> b,c,s9  (branch if bit c in reg b is set)
#BBIT1<.d><.T> b,u6,s9 (branch if bit u6 in reg b is set)

#BBIT1<.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y111
#BBIT1<.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y111

:bbit1^f32_br1_branch_prediction_bit   		f32_B_dst, f32_br1_C_U6_src, f32_br1_S9   	is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b111 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_B_dst & f32_br1_S9) ... & f32_br1_C_U6_src {
  if ((f32_B_dst & (1:4 << f32_br1_C_U6_src[0,5])) != 0:4) goto f32_br1_S9;
}

:bbit1.d^f32_br1_branch_prediction_bit 	f32_B_dst, f32_br1_C_U6_src, f32_br1_S9 	is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b111 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_B_dst & f32_br1_S9) ... & f32_br1_C_U6_src {
  
  delayslot(1);
  if ((f32_B_dst & (1:4 << f32_br1_C_U6_src[0,5])) != 0:4) goto f32_br1_S9;
}

# --------------------------------------------- BL ---------------------------------------------
#BL<.d> s25 (unconditional branch far)

#BL<.d> s25 00001sssssssss10 SSSSSSSSSSNRtttt
:bl f32_br1_S25                         is F32_MAJOR_OPCODE=$(F32_BR1) & f32_delay_bit=0b0 & f32_bit16=0b0 & f32_bit17=0b1 & f32_br1_S25 {
  blink = inst_next;
  call f32_br1_S25;
}
  
:bl.d f32_br1_S25                    is F32_MAJOR_OPCODE=$(F32_BR1) & f32_delay_bit=0b1 & f32_bit16=0b0 & f32_bit17=0b1 & f32_br1_S25 {      
  blink = inst_next;
  delayslot(1);
  call f32_br1_S25;
}

# --------------------------------------------- BLcc ---------------------------------------------
#BLcc<.d>    s21 (branch if condition is true)

#BL<.cc><.d> s21 00001sssssssss00 SSSSSSSSSSNQQQQQ
:bl^f32_br0_cc f32_br1_S21        is F32_MAJOR_OPCODE=$(F32_BR1) & f32_delay_bit=0b0 & f32_bit16=0b0 & f32_bit17=0b0 & f32_br1_S21 & f32_br0_cc {
  if (f32_br0_cc == 0:1) goto inst_next;
  blink = inst_next;
  call f32_br1_S21;
}

:bl^f32_br0_cc^".d" f32_br1_S21   is F32_MAJOR_OPCODE=$(F32_BR1) & f32_delay_bit=0b1 & f32_bit16=0b0 & f32_bit17=0b0 & f32_br1_S21 & f32_br0_cc {    
  if (f32_br0_cc == 0:1) goto inst_next;
  blink = inst_next;
  delayslot(1);
  call f32_br1_S21;
}

# --------------------------------------------- BRcc ---------------------------------------------
#BRcc<.d><.T> b,c,s9 	(branch if reg-reg compare is true, swap regs if inverse condition required)
#BRcc<.T>     b,limm,s9 (branch if reg-limm compare is true)
#BRcc<.T>     limm,c,s9 (branch if limm-reg compare is true)
#BRcc<.d><.T> b,u6,s9 	(branch if reg-immediate compare is true, use "immediate+1" if a missing condition is required)

#BREQ <.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y000
#BREQ <.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y000
#BRNE <.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y001
#BRNE <.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y001
#BRLT <.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y010
#BRLT <.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y010
#BRGE <.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y011
#BRGE <.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y011
#BRLO <.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y100
#BRLO <.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y100
#BRHS <.d><.T> b,c,s9  00001bbbsssssss1 SBBBCCCCCCN0Y101
#BRHS <.d><.T> b,u6,s9 00001bbbsssssss1 SBBBuuuuuuN1Y101

:breq^f32_br1_branch_prediction_bit     f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b000 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  if (f32_B_src == f32_br1_C_U6_src) goto f32_br1_S9; 
}

:breq.d^f32_br1_branch_prediction_bit f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b000 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  if (f32_B_src == f32_br1_C_U6_src) goto f32_br1_S9; 
}

:brne^f32_br1_branch_prediction_bit     f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b001 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  if (f32_B_src != f32_br1_C_U6_src) goto f32_br1_S9;
}

:brne.d^f32_br1_branch_prediction_bit f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b001 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  delayslot(1);
  if (f32_B_src != f32_br1_C_U6_src) goto f32_br1_S9;
}

:brlt^f32_br1_branch_prediction_bit     f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b010 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  if (f32_B_src s< f32_br1_C_U6_src) goto f32_br1_S9;
}

:brlt.d^f32_br1_branch_prediction_bit f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b010 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  delayslot(1);
  if (f32_B_src s< f32_br1_C_U6_src) goto f32_br1_S9;
}

:brge^f32_br1_branch_prediction_bit     f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b011 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  if (f32_B_src s>= f32_br1_C_U6_src) goto f32_br1_S9;
}

:brge.d^f32_br1_branch_prediction_bit f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b011 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  delayslot(1);
  if (f32_B_src s>= f32_br1_C_U6_src) goto f32_br1_S9;
}

:brlo^f32_br1_branch_prediction_bit     f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b100 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  if (f32_B_src < f32_br1_C_U6_src) goto f32_br1_S9;
}

:brlo.d^f32_br1_branch_prediction_bit f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b100 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  delayslot(1);
  if (f32_B_src < f32_br1_C_U6_src) goto f32_br1_S9;
}

:brhs^f32_br1_branch_prediction_bit     f32_B_src, f32_br1_C_U6_src, f32_br1_S9 is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b101 & f32_bit16=0b1 & f32_bit5=0b0 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  if (f32_B_src >= f32_br1_C_U6_src) goto f32_br1_S9;
}

:brhs.d^f32_br1_branch_prediction_bit f32_B_src, f32_br1_C_U6_src, f32_br1_S9  is (F32_MAJOR_OPCODE=$(F32_BR1) & f32_br1_i_0_2=0b101 & f32_bit16=0b1 & f32_bit5=0b1 & f32_br1_branch_prediction_bit & f32_br1_S9) ... & f32_B_src & f32_br1_C_U6_src {
  delayslot(1);
  if (f32_B_src >= f32_br1_C_U6_src) goto f32_br1_S9;
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F32_LD_OFFSET 0b00010
# ***********************************************************************************************
# ***********************************************************************************************
#LD<zz><.x><.aa><.di> a,[b,s9]
#LD<zz><.x><.di>      a,[limm,s9] (use ld a,[limm])
#LD<zz><.x><.di>      a,[limm] (= ld a,[limm,0])

#LD<zz><.x><.aa><.di> a,[b]    00010bbb00000000 0BBBDaaZZXAAAAAA
#LD<zz><.x><.aa><.di> a,[b,s9] 00010bbbssssssss SBBBDaaZZXAAAAAA


:ld f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b00 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:4 = *[ram]:4 addr;
  f32_A_dst = zext(val);
}

:ld.a f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b01 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:4 = *[ram]:4 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = zext(val);
}

:ld.ab f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b10 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src;
  local val:4 = *[ram]:4 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = zext(val);
}

:ld.as f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b11 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:4 = *[ram]:4 addr;
  f32_A_dst = zext(val);
}

:ld.x f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b00 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:4 = *[ram]:4 addr;
  f32_A_dst = sext(val);
}

:ld.x.a f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b01 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:4 = *[ram]:4 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = sext(val);
}

:ld.x.ab f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b10 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src;
  local val:4 = *[ram]:4 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = sext(val);
}

:ld.x.as f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b00 & f32_ld_offset_aa=0b11 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:4 = *[ram]:4 addr;
  f32_A_dst = sext(val);
}

:ldb f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b00 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:1 = *[ram]:1 addr;
  f32_A_dst = zext(val);
}

:ldb.a f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b01 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:1 = *[ram]:1 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = zext(val);
}

:ldb.ab f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b10 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src;
  local val:1 = *[ram]:1 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = zext(val);
}

:ldb.as f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b11 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:1 = *[ram]:1 addr;
  f32_A_dst = zext(val);
}

:ldb.x f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b00 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:1 =  *[ram]:1 addr;
  f32_A_dst = sext(val);
}

:ldb.x.a f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b01 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:1 =  *[ram]:1 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = sext(val);
}

:ldb.x.ab f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b10 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src;
  local val:1 =  *[ram]:1 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = sext(val);
}

:ldb.x.as f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b01 & f32_ld_offset_aa=0b11 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:1 =  *[ram]:1 addr;
  f32_A_dst = sext(val);
}

:ldh f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b00 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:2 = *[ram]:2 addr;
  f32_A_dst = zext(val);
}

:ldh.a f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b01 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:2 = *[ram]:2 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = zext(val);
}

:ldh.ab f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b10 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src;
  local val:2 = *[ram]:2 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = zext(val);
}

:ldh.as f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b0 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b11 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:2 = *[ram]:2 addr;
  f32_A_dst = zext(val);
}

:ldh.x f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b00 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:2 = *[ram]:2 addr;
  f32_A_dst = sext(val);
}

:ldh.x.a f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b01 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:2 = *[ram]:2 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = sext(val);
}

:ldh.x.ab f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b10 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:2 = *[ram]:2 addr;
  f32_B_src = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  f32_A_dst = sext(val);
}

:ldh.x.as f32_A_dst, [f32_B_src, f32_ld_offset_S9_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_LD_OFFSET) & f32_A_dst & f32_ld_offset_X=0b1 & f32_ld_offset_ZZ=0b10 & f32_ld_offset_aa=0b11 & f32_ld_offset_D & f32_ld_offset_S9_aa_zz_src) ... & f32_B_src {
  local addr:4 = f32_B_src + f32_ld_offset_S9_aa_zz_src;
  local val:2 = *[ram]:2 addr;
  f32_A_dst = sext(val);
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F32_ST_OFFSET
# ***********************************************************************************************
# ***********************************************************************************************
#ST<zz><.aa><.di> c,[b,s9]
#ST<zz><.di>      c,[limm] (= st c,[limm,0])
#ST<zz><.aa><.di> limm,[b,s9]

#ST<zz><.aa><.di> c,[b]     00011bbb000000000BBBCCCCCCDaaZZ0
#ST<zz><.aa><.di> c,[b,s9]  00011bbbssssssssSBBBCCCCCCDaaZZ0
#ST<zz><.aa><.di> w6,[b]    00011bbb000000000BBBwwwwwwDaaZZ1
#ST<zz><.aa><.di> w6,[b,s9] 00011bbbssssssssSBBBwwwwwwDaaZZ1

:st^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b00 & f32_st_offset_aa=0b00 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
    
  *:4 addr = f32_st_offset_C_W_dst:4;
}

:stb^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b01 & f32_st_offset_aa=0b00 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
    
	*:1 addr = f32_st_offset_C_W_dst:1; 
}

:sth^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b10 & f32_st_offset_aa=0b00 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
    
	*:2 addr = f32_st_offset_C_W_dst:2; 
}

:st.a^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b00 & f32_st_offset_aa=0b01 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
  *:4 addr = f32_st_offset_C_W_dst:4;
  f32_B_src = f32_B_src + f32_st_offset_S9_aa_zz_src;
}

:stb.a^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b01 & f32_st_offset_aa=0b01 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
	*:1 addr = f32_st_offset_C_W_dst:1;
  f32_B_src = f32_B_src + f32_st_offset_S9_aa_zz_src;
}

:sth.a^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b10 & f32_st_offset_aa=0b01 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
	*:2 addr = f32_st_offset_C_W_dst:2;
  f32_B_src = f32_B_src + f32_st_offset_S9_aa_zz_src;
}

:st.ab^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b00 & f32_st_offset_aa=0b10 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src;
  *:4 addr = f32_st_offset_C_W_dst:4; 
  f32_B_src = f32_B_src + f32_st_offset_S9_aa_zz_src;
}

:stb.ab^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b01 & f32_st_offset_aa=0b10 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src;
	*:1 addr = f32_st_offset_C_W_dst:1;
	f32_B_src = f32_B_src + f32_st_offset_S9_aa_zz_src;
}

:sth.ab^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b10 & f32_st_offset_aa=0b10 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src;
	*:2 addr = f32_st_offset_C_W_dst:2;
  f32_B_src = f32_B_src + f32_st_offset_S9_aa_zz_src;
}

:st.as^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b00 & f32_st_offset_aa=0b11 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
  *:4 addr = f32_st_offset_C_W_dst:4;
}

:stb.as^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b01 & f32_st_offset_aa=0b11 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
	*:1 addr = f32_st_offset_C_W_dst:1;
}

:sth.as^f32_st_offset_d f32_st_offset_C_W_dst, [f32_B_src, f32_st_offset_S9_aa_zz_src]   is (F32_MAJOR_OPCODE=$(F32_ST_OFFSET) & f32_st_offset_S9_aa_zz_src & f32_st_offset_ZZ=0b10 & f32_st_offset_aa=0b11 & f32_st_offset_d) ... & f32_st_offset_C_W_dst & f32_B_src {
  local addr:4 = f32_B_src + f32_st_offset_S9_aa_zz_src;
	*:2 addr = f32_st_offset_C_W_dst:2;
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F32_GEN4 00100
# ***********************************************************************************************
# ***********************************************************************************************

# --------------------------------------------- ABC ---------------------------------------------
# sop<.f> b,c
# sop<.f> b,limm 	(If C= 62)
# sop<.f> 0,c 		(If B = 62)
# sop<.f> 0,limm 	(If B = C = 62, not a useful format)
# sop<.f> b,u6
# sop<.f> 0,u6 		(If B = 62)

# ABS<.f> b,c  00100bbb00101111 FBBBCCCCCC001001
# ABS<.f> b,u6 00100bbb01101111 FBBBuuuuuu001001
:abs f32_B_dst, f32_C_U6_src                       is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_dst & f32_bit_F=0b0) ... & f32_C_U6_src {
  local acond:1 = (f32_C_U6_src s< 0:4);

  f32_B_dst = f32_B_dst*zext(acond == 0:1)-f32_C_U6_src*zext(acond != 0:1);
}

:abs.f f32_B_dst, f32_C_U6_src                       is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_dst & f32_bit_F=0b1) ... & f32_C_U6_src {
  local acond:1 = (f32_C_U6_src s< 0:4);
  f32_B_dst = f32_B_dst*zext(acond == 0:1)-f32_C_U6_src*zext(acond != 0:1);
  
  Z = (f32_B_dst == 0:4);
  N = (f32_C_U6_src == 0x80000000:4);
  C = (f32_C_U6_src s< 0:4);
  V = (f32_C_U6_src == 0x80000000:4);
}

:abs f32_B_dst, f32_C_U6_src                       is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_B_dst & f32_bit_F=0b0) ... & f32_C_U6_src {

}

:abs.f f32_B_dst, f32_C_U6_src                       is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_B_dst & f32_bit_F=0b1) ... & f32_C_U6_src {
  local acond:1 = (f32_C_U6_src s< 0:4);
  local dest:4 = f32_B_dst*zext(acond == 0:1)-f32_C_U6_src*zext(acond != 0:1);
  
  Z = (dest == 0:4);
  N = (f32_C_U6_src == 0x80000000:4);
  C = (f32_C_U6_src s< 0:4);
  V = (f32_C_U6_src == 0x80000000:4);
}


# --------------------------------------------- ADC ---------------------------------------------
# dop<.f> a,b,c
# dop<.f> a,limm,c 			(If B = 62)
# dop<.f> a,b,limm 			(If C= 62)
# dop<.f> a,limm,limm 		(If B = C = 62, not a useful format)
# dop<.f> 0,b,c 			(If A = 62)
# dop<.f> 0,limm,c 			(Redundant format, see General Operations Conditional Register format on page 351)
# dop<.f> 0,b,limm 			(If A = 62, B = 62)
# dop<.f> 0,limm,limm 		(If A = 0, B = C = 62, not a useful format)
# dop<.f> a,b,u6
# dop<.f> a,limm,u6 		(If B = 62, not useful format)
# dop<.f> 0,b,u6 			(If A = 62)
# dop<.f> 0,limm,u6 		(If A = B = 62, not useful format)
# dop<.f> b,b,s12
# dop<.f> 0,limm,s12 		(If B = 62, not a useful format)
# dop<.cc><.f> b,b,c
# dop<.cc><.f> 0,limm,c 	(If B = 62)
# dop<.cc><.f> b,b,limm 	(If C = 62)
# dop<.cc><.f> 0,limm,limm 	(If B = C = 62, not a useful format)

# ADC<.f> 		a,b,c 	00100bbb00000001 FBBBCCCCCCAAAAAA
# ADC<.f> 		a,b,u6 	00100bbb01000001 FBBBuuuuuuAAAAAA
# ADC<.f> 		b,b,s12 00100bbb10000001 FBBBssssssSSSSSS
# ADC<.cc><.f> 	b,b,c 	00100bbb11000001 FBBBCCCCCC0QQQQQ
# ADC<.cc><.f> 	b,b,u6 	00100bbb11000001 FBBBuuuuuu1QQQQQ

:adc^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000001 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src + f32_C_U6_S12_src + zext(C);
}

:adc^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000001 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src + f32_C_U6_S12_src + zext(C);
    
  local sign_a:1 = (f32_A_B_dst s< 0:4); 
  local sign_b:1 = (f32_B_src s< 0:4);
  local sign_c:1 = (f32_C_U6_S12_src s< 0:4);
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);

  C = carry(f32_B_src, f32_C_U6_S12_src) || carry(f32_B_src + f32_C_U6_S12_src, zext(C));
  V = (sign_b == sign_c) && (sign_a != sign_b);
}

:adc^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000001  & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src + f32_C_U6_S12_src + zext(C); 
  
  if (f32_bit_F == 0:1) goto inst_next;
  local sign_a:1 = (dest s< 0:4); 
  local sign_b:1 = (f32_B_src s< 0:4);
  local sign_c:1 = (f32_C_U6_S12_src s< 0:4);
  
  UPDATE_FLAGS_ZN(dest);

  C = carry(f32_B_src, f32_C_U6_S12_src) || carry(f32_B_src + f32_C_U6_S12_src, zext(C));
  V = (sign_b == sign_c) && (sign_a != sign_b);
}

# --------------------------------------------- ADD ---------------------------------------------
# dop
# ADD<.f>      a,b,c   00100 bbb 00 000000 FBBBCCCCCCAAAAAA
# ADD<.f>      a,b,u6  00100 bbb 01 000000 FBBBuuuuuuAAAAAA
# ADD<.f>      b,b,s12 00100 bbb 10 000000 FBBBssssssSSSSSS
# ADD<.cc><.f> b,b,c   00100 bbb 11 000000 FBBBCCCCCC0QQQQQ
# ADD<.cc><.f> b,b,u6  00100 bbb 11 000000 FBBBuuuuuu1QQQQQ

:add^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000000 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src + f32_C_U6_S12_src;  
}

:add^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000000 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src + f32_C_U6_S12_src;
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = carry(f32_B_src, f32_C_U6_S12_src);
  V = scarry(f32_B_src, f32_C_U6_S12_src);  
}

:add^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000000  & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local dest:4 = f32_B_src + f32_C_U6_S12_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = carry(f32_B_src, f32_C_U6_S12_src);
  V = scarry(f32_B_src, f32_C_U6_S12_src);  
}

# --------------------------------------------- ADD1 ---------------------------------------------
# dop
# ADD1<.f>      a,b,c   00100 bbb 00 010100 FBBBCCCCCCAAAAAA
# ADD1<.f>      a,b,u6  00100 bbb 01 010100 FBBBuuuuuuAAAAAA
# ADD1<.f>      b,b,s12 00100 bbb 10 010100 FBBBssssssSSSSSS
# ADD1<.cc><.f> b,b,c   00100 bbb 11 010100 FBBBCCCCCC0QQQQQ
# ADD1<.cc><.f> b,b,u6  00100 bbb 11 010100 FBBBuuuuuu1QQQQQ

:add1^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010100 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 1;
  f32_A_B_dst  = f32_B_src + shift;
}

:add1^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010100 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 1;
  f32_A_B_dst  = f32_B_src + shift;
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = carry(f32_B_src, shift);
  V = scarry(f32_B_src, shift);
}


:add1^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010100  & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 1;
  local dest:4  = f32_B_src + shift;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = carry(f32_B_src, shift);
  V = scarry(f32_B_src, shift);
  #V = (f32_B_src[31,1] && shift[31,1] && ~dest[31,1]) || (~f32_B_src[31,1] && ~shift[31,1] && dest[31,1]);
}

# --------------------------------------------- ADD2 ---------------------------------------------
# dop
# ADD2<.f>      a,b,c   00100 bbb 00 010101 FBBBCCCCCCAAAAAA
# ADD2<.f>      a,b,u6  00100 bbb 01 010101 FBBBuuuuuuAAAAAA
# ADD2<.f>      b,b,s12 00100 bbb 10 010101 FBBBssssssSSSSSS
# ADD2<.cc><.f> b,b,c   00100 bbb 11 010101 FBBBCCCCCC0QQQQQ
# ADD2<.cc><.f> b,b,u6  00100 bbb 11 010101 FBBBuuuuuu1QQQQQ

:add2^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010101 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 2;
  f32_A_B_dst = f32_B_src + shift;
}

:add2^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010101 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 2;
  f32_A_B_dst = f32_B_src + shift;

  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = carry(f32_B_src, shift);
  V = scarry(f32_B_src, shift);
}

:add2^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010101 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 2;
  local dest:4 = f32_B_src + shift;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = carry(f32_B_src, shift);
  V = scarry(f32_B_src, shift);
  #V = (f32_B_src[31,1] && shift[31,1] && ~dest[31,1]) || (~f32_B_src[31,1] && ~shift[31,1] && dest[31,1]); 
}

# --------------------------------------------- ADD3 ---------------------------------------------
# dop
# ADD3<.f>      a,b,c   00100bbb00 010110 FBBBCCCCCCAAAAAA
# ADD3<.f>      a,b,u6  00100bbb01 010110 FBBBuuuuuuAAAAAA
# ADD3<.f>      b,b,s12 00100bbb10 010110 FBBBssssssSSSSSS
# ADD3<.cc><.f> b,b,c   00100bbb11 010110 FBBBCCCCCC0QQQQQ
# ADD3<.cc><.f> b,b,u6  00100bbb11 010110 FBBBuuuuuu1QQQQQ

:add3^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010110 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 3;
  f32_A_B_dst = f32_B_src + shift;
}

:add3^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010110 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 3;
  f32_A_B_dst = f32_B_src + shift;
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = carry(f32_B_src, shift);
  V = scarry(f32_B_src, shift);
}

:add3^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010110 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = f32_C_U6_S12_src << 3;
  local dest:4 = f32_B_src + shift;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = carry(f32_B_src, shift);
  V = scarry(f32_B_src, shift);
  #V = (f32_B_src[31,1] && shift[31,1] && ~dest[31,1]) || (~f32_B_src[31,1] && ~shift[31,1] && dest[31,1]); 
}

# --------------------------------------------- AEX ---------------------------------------------
# AEX is listed as a DOP instruction (Table 8-4)

# AEX      b,[c]   00100bbb00 100111 RBBBCCCCCCRRRRRR
# AEX      b,[u6]  00100bbb01 100111 RBBBuuuuuuRRRRRR
# AEX      b,[s12] 00100bbb10 100111 RBBBssssssSSSSSS
# AEX<.cc> b,[c]   00100bbb11 100111 RBBBCCCCCC0QQQQQ
# AEX<.cc> b,[u6]  00100bbb11 100111 RBBBuuuuuu1QQQQQ

:aex^f32_cc f32_B_dst, [f32_C_U6_S12_src] is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100111 & f32_B_dst & f32_cc) ... & f32_C_U6_S12_src {
	build f32_cc;
	local temp:4 = *[AUX_REGS_BASE]:4 (f32_C_U6_S12_src:4); 
	*[AUX_REGS_BASE]:4 (f32_C_U6_S12_src:4) = f32_B_dst;
	f32_B_dst = temp;		
}

# --------------------------------------------- AND ---------------------------------------------
# dop
# AND<.f>      a,b,c   00100bbb00 000100 FBBBCCCCCCAAAAAA
# AND<.f>      a,b,u6  00100bbb01 000100 FBBBuuuuuuAAAAAA
# AND<.f>      b,b,s12 00100bbb10 000100 FBBBssssssSSSSSS
# AND<.cc><.f> b,b,c   00100bbb11 000100 FBBBCCCCCC0QQQQQ
# AND<.cc><.f> b,b,u6  00100bbb11 000100 FBBBuuuuuu1QQQQQ

#Here I experimented with another way of implementing the same instruction
f32_gen4_and: "" is (f32_A_B_dst & f32_bit_F=0b0) ... & f32_C_U6_S12_src & f32_B_src {
	f32_A_B_dst = f32_B_src & f32_C_U6_S12_src;
}

f32_gen4_and: "" is (f32_A_B_dst & f32_bit_F=0b1) ... & f32_C_U6_S12_src & f32_B_src {
	f32_A_B_dst = f32_B_src & f32_C_U6_S12_src;
	UPDATE_FLAGS_ZN(f32_A_B_dst);   
}

f32_gen4_and: "" is (f32_bit_F=0b1 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110))) ... & f32_C_U6_S12_src & f32_B_src {
	local dest:4 = f32_B_src & f32_C_U6_S12_src;
	UPDATE_FLAGS_ZN(dest);   
}

:and^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000100 & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src & f32_gen4_and {
  build f32_cc;
  
  build f32_gen4_and;  
}

#:and^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000100 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
#  build f32_cc;
#  
#  f32_A_B_dst = f32_B_src & f32_C_U6_S12_src;
#  
#  UPDATE_FLAGS_ZN(f32_A_B_dst);    
#}

#:and^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000100 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
#  build f32_cc;
#  
#  local dest:4 = f32_B_src & f32_C_U6_S12_src;
#  
#  if (f32_bit_F == 0:1) goto inst_next;
#  UPDATE_FLAGS_ZN(dest);    
#}

# --------------------------------------------- ASL ---------------------------------------------
# sop
# sop<.f> b,c
# sop<.f> b,limm (If C= 62)
# sop<.f> 0,c (If B = 62)
# sop<.f> 0,limm (If B = C = 62, not a useful format)
# sop<.f> b,u6
# sop<.f> 0,u6 (If B = 62)

# ASL<.f> b,c  00100 bbb 00 101111 FBBBCCCCCC 000000
# ASL<.f> b,u6 00100 bbb 01 101111 FBBBuuuuuu 000000

:asl f32_B_dst, f32_C_U6_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000000 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src << 1;
}

:asl.f f32_B_dst, f32_C_U6_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000000 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src << 1;

  UPDATE_FLAGS_ZN(f32_B_dst); 
  C = carry(f32_C_U6_src, f32_C_U6_src);
  V = scarry(f32_C_U6_src, f32_C_U6_src); 
}

:asl^f32_bit_F f32_B_dst, f32_C_U6_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000000 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src << 1;

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest); 
  C = carry(f32_C_U6_src, f32_C_U6_src);
  V = scarry(f32_C_U6_src, f32_C_U6_src); 
}

# --------------------------------------------- ASR ---------------------------------------------
# sop
# ASR<.f> b,c  00100 bbb 00 101111 FBBBCCCCCC 000001
# ASR<.f> b,u6 00100 bbb 01 101111 FBBBuuuuuu 000001

:asr f32_B_dst, f32_C_U6_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000001 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src s>> 1;
}

:asr.f f32_B_dst, f32_C_U6_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000001 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src s>> 1;

  UPDATE_FLAGS_ZN(f32_B_dst); 
  C = (f32_C_U6_src:1) & 1:1; 
}

:asr^f32_bit_F f32_B_dst, f32_C_U6_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000001 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src s>> 1;

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest); 
  C = (f32_C_U6_src:1) & 1:1; 
}

# --------------------------------------------- BCLR ---------------------------------------------
# dop
# BCLR<.f>      a,b,c   00100bbb00 010000 FBBBCCCCCCAAAAAA
# BCLR<.f>      a,b,u6  00100bbb01 010000 FBBBuuuuuuAAAAAA
# BCLR<.f>      b,b,s12 00100bbb10 010000 FBBBssssssSSSSSS
# BCLR<.cc><.f> b,b,c   00100bbb11 010000 FBBBCCCCCC0QQQQQ
# BCLR<.cc><.f> b,b,u6  00100bbb11 010000 FBBBuuuuuu1QQQQQ


:bclr^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010000 & f32_bit_F & f32_cc & f32_A_B_dst & gen4_f32_A_B_dst_ZN) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src & ~(1:4 << f32_C_U6_S12_src[0, 5]);
  
  build gen4_f32_A_B_dst_ZN;  
}

:bclr^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010000 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src & ~(1:4 << f32_C_U6_S12_src[0, 5]);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
}

# --------------------------------------------- BI ---------------------------------------------
# BI is listed as a DOP instruction in Table 8-4.

# BI [c] 00100 RRR 00 100100 0 RRRCCCCCCRRRRRR
:bi [f32_C_src] is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b100100 & f32_bits_22_23=0b00 & f32_bit_F=0b0) ... & f32_C_src {
  	goto [inst_next + (f32_C_src << 2)];
}

# --------------------------------------------- BIC ---------------------------------------------
# BIC<.f>      a,b,c   00100bbb00 000110 FBBBCCCCCCAAAAAA
# BIC<.f>      a,b,u6  00100bbb01 000110 FBBBuuuuuuAAAAAA
# BIC<.f>      b,b,s12 00100bbb10 000110 FBBBssssssSSSSSS
# BIC<.cc><.f> b,b,c   00100bbb11 000110 FBBBCCCCCC0QQQQQ
# BIC<.cc><.f> b,b,u6  00100bbb11 000110 FBBBuuuuuu1QQQQQ

:bic^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000110 & f32_bit_F & f32_cc & f32_A_B_dst & gen4_f32_A_B_dst_ZN) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src & ~f32_C_U6_S12_src;
  
  build gen4_f32_A_B_dst_ZN;
}

:bic^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000110 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src & ~f32_C_U6_S12_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);   
}


# --------------------------------------------- BIH ---------------------------------------------
# BI is listed as a DOP instruction in Table 8-4.

# BIH [c] 00100RRR001001010RRRCCCCCCRRRRRR
:bih [f32_C_src]  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b100101 & f32_bit23=0b0 & f32_bit22=0b0 & f32_bit_F ) ... & f32_C_src {
  goto [inst_next + (f32_C_src << 1)];
}

# --------------------------------------------- BMSK ---------------------------------------------
# dop
# BMSK<.f>      a,b,c   00100bbb00 010011 FBBBCCCCCCAAAAAA
# BMSK<.f>      a,b,u6  00100bbb01 010011 FBBBuuuuuuAAAAAA
# BMSK<.f>      b,b,s12 00100bbb10 010011 FBBBssssssSSSSSS
# BMSK<.cc><.f> b,b,c   00100bbb11 010011 FBBBCCCCCC0QQQQQ
# BMSK<.cc><.f> b,b,u6  00100bbb11 010011 FBBBuuuuuu1QQQQQ

:bmsk^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010011 & f32_bit_F & f32_cc & f32_A_B_dst & gen4_f32_A_B_dst_ZN) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src & ((1:4 << ((f32_C_U6_S12_src & 31) + 1)) - 1);
 
  build gen4_f32_A_B_dst_ZN;
}

:bmsk^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010011 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local dest:4 = f32_B_src & ((1:4 << ((f32_C_U6_S12_src & 31) + 1)) - 1);
 
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest); 
}


# --------------------------------------------- BMSKN ---------------------------------------------
# dop
# BMSKN<.f>      a,b,c   00100bbb00101100FBBBCCCCCCAAAAAA
# BMSKN<.f>      a,b,u6  00100bbb01101100FBBBuuuuuuAAAAAA
# BMSKN<.f>      b,b,s12 00100bbb10101100FBBBssssssSSSSSS
# BMSKN<.cc><.f> b,b,c   00100bbb11101100FBBBCCCCCC0QQQQQ
# BMSKN<.cc><.f> b,b,u6  00100bbb11101100FBBBuuuuuu1QQQQQ


:bmskn^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101100 & f32_bit_F & f32_cc & f32_A_B_dst & gen4_f32_A_B_dst_ZN) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src & ~((1:4 << ((f32_C_U6_S12_src & 31) + 1)) - 1);
  
  build gen4_f32_A_B_dst_ZN; 
}

:bmskn^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101100 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src & ~((1:4 << ((f32_C_U6_S12_src & 31) + 1)) - 1);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest); 
}

# --------------------------------------------- BRK ---------------------------------------------
# zop<.f> c
# zop<.f> limm (If C = 62)
# zop<.f> u6

# BRK 00100101011011110000RRRRRR111111
:brk                                                   is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b111111 & f32_gen4_dop_U6 & f32_B_3_5=0b000 & f32_bit_F=0b0 & f32_gen4_dop_i=0b101111 & f32_gen4_dop_aa=0b01 & f32_B0_b_0_2=0b101 {
  H = 1:1;
}

# --------------------------------------------- BSET ---------------------------------------------
# dop
# BSET<.f>      a,b,c   00100bbb00 001111 FBBBCCCCCCAAAAAA
# BSET<.f>      a,b,u6  00100bbb01 001111 FBBBuuuuuuAAAAAA
# BSET<.f>      b,b,s12 00100bbb10 001111 FBBBssssssSSSSSS
# BSET<.cc><.f> b,b,c   00100bbb11 001111 FBBBCCCCCC0QQQQQ
# BSET<.cc><.f> b,b,u6  00100bbb11 001111 FBBBuuuuuu1QQQQQ

:bset^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001111 & f32_bit_F & f32_cc & f32_A_B_dst & gen4_f32_A_B_dst_ZN) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src | (1:4 << (f32_C_U6_S12_src & 31));
  
  build gen4_f32_A_B_dst_ZN;
}

:bset^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001111 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local dest:4 = f32_B_src | (1:4 << (f32_C_U6_S12_src & 31));
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
}

# --------------------------------------------- BTST ---------------------------------------------
# dop
# BTST      b,c   00100bbb00 010001 1 BBBCCCCCCRRRRRR
# BTST      b,u6  00100bbb01 010001 1 BBBuuuuuuRRRRRR
# BTST      b,s12 00100bbb10 010001 1 BBBssssssSSSSSS
# BTST<.cc> b,c   00100bbb11 010001 1 BBBCCCCCC0QQQQQ
# BTST<.cc> b,u6  00100bbb11 010001 1 BBBuuuuuu1QQQQQ

:btst^f32_cc f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010001 & f32_bit_F=0b1 & f32_cc) ... & f32_B_src & f32_C_U6_S12_src {
	build f32_cc;
	local dest:4 = f32_B_src & (1:4 << (f32_C_U6_S12_src & 31)); 
	UPDATE_FLAGS_ZN(dest);  	
}

# --------------------------------------------- BXOR ---------------------------------------------
# dop
# BXOR<.f>      a,b,c   00100bbb00 010010 FBBBCCCCCCAAAAAA
# BXOR<.f>      a,b,u6  00100bbb01 010010 FBBBuuuuuuAAAAAA
# BXOR<.f>      b,b,s12 00100bbb10 010010 FBBBssssssSSSSSS
# BXOR<.cc><.f> b,b,c   00100bbb11 010010 FBBBCCCCCC0QQQQQ
# BXOR<.cc><.f> b,b,u6  00100bbb11 010010 FBBBuuuuuu1QQQQQ

:bxor^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010010 & f32_bit_F & f32_cc & f32_A_B_dst & gen4_f32_A_B_dst_ZN) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src ^ (1:4 << (f32_C_U6_S12_src & 31));
 
  build gen4_f32_A_B_dst_ZN;  
}

:bxor^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010010 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110))  & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local dest:4 = f32_B_src ^ (1:4 << (f32_C_U6_S12_src & 31));
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);   
}


# --------------------------------------------- CLRI ---------------------------------------------
# zop
# CLRI c   0010011100 101111 0 000cccccc111111
# CLRI u6  0010011101 101111 0 000uuuuuu111111

:clri f32_C_U6_src                  is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b111111 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b000 & f32_B0_b_0_2=0b111 & f32_bit_F=0b0) ... & f32_C_U6_src  {
	*:4 f32_C_U6_src = 0x00000020 | (zext(IE) << 4) | zext(E);
	IE = 0:1;
}

# --------------------------------------------- CMP ---------------------------------------------
# f32_bit_F=0b1 but in other places in the doc this value is different
# dop
# CMP      b,c   00100bbb00 001100 1BBBCCCCCCRRRRRR
# CMP      b,u6  00100bbb01 001100 1BBBuuuuuuRRRRRR
# CMP      b,s12 00100bbb10 001100 1BBBssssssSSSSSS
# CMP<.cc> b,c   00100bbb11 001100 1BBBCCCCCC0QQQQQ
# CMP<.cc> b,u6  00100bbb11 001100 1BBBuuuuuu1QQQQQ

:cmp^f32_cc f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001100 & f32_cc ) ... & f32_B_src & f32_C_U6_S12_src {
  build f32_cc;
  local dest:4 = f32_B_src - f32_C_U6_S12_src; 
  UPDATE_FLAGS_ZN(dest);  
  C = f32_B_src < f32_C_U6_S12_src;
  V = sborrow(f32_B_src, f32_C_U6_S12_src); 	
}

# --------------------------------------------- DBNZ ---------------------------------------------
# dop
# DBNZ<.d> b,s13 00100bbb1000110N 0BBBssssssSSSSSS

:dbnz f32_B_dst, f32_gen4_dbnz_S13  		is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_B_dst & f32_gen4_dbnz_S13 & f32_gen4_dop_N=0b0 & f32_gen4_dop_i_1_5=0b00110 & f32_bits_22_23=0b10 & f32_bit15=0b0 {
	f32_B_dst = f32_B_dst - 1;
	if (f32_B_dst == 0:4) goto inst_next;
	goto f32_gen4_dbnz_S13;	
}

:dbnz".d" f32_B_dst, f32_gen4_dbnz_S13  	is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_B_dst & f32_gen4_dbnz_S13 & f32_gen4_dop_N=0b1 & f32_gen4_dop_i_1_5=0b00110 & f32_bits_22_23=0b10 & f32_bit15=0b0 {
	f32_B_dst = f32_B_dst - 1;
	if (f32_B_dst == 0:4) goto inst_next;
	delayslot(1);
	goto f32_gen4_dbnz_S13;	
}

# --------------------------------------------- EX ---------------------------------------------
# sop
# EX<.di> b,[c]  00100bbb00101111 DBBBCCCCCC001100
# EX<.di> b,[u6] 00100bbb01101111 DBBBuuuuuu001100

:ex^f32_gen4_dop_D f32_B_dst, [f32_C_U6_src]                          is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b001100 & f32_B_dst & f32_gen4_dop_D) ... & f32_C_U6_src{
  local temp:4 = f32_B_dst;
  f32_B_dst = *[ram]:4 f32_C_U6_src;
  *[ram]:4 f32_C_U6_src = temp; 
}

# --------------------------------------------- EXTB ---------------------------------------------
# sop
# EXTB<.f> b,c  00100bbb00101111 FBBBCCCCCC000111
# EXTB<.f> b,u6 00100bbb01101111 FBBBuuuuuu000111
 
:extb^f32_bit_F f32_B_dst, [f32_C_U6_src]                          is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000111 & f32_B_dst & f32_bit_F & gen4_f32_B_dst_ZN) ... & f32_C_U6_src{
  f32_B_dst = zext(f32_C_U6_src:1);
  
  build gen4_f32_B_dst_ZN;
}

:extb^f32_bit_F f32_B_dst, [f32_C_U6_src]                          is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_B_dst & f32_bit_F) ... & f32_C_U6_src{
  local dest:4 = zext(f32_C_U6_src:1);
  UPDATE_FLAGS_ZN(dest); 
}

# --------------------------------------------- EXTH ---------------------------------------------
# sop
# EXTH<.f> b,c  00100bbb00101111 FBBBCCCCCC001000
# EXTH<.f> b,u6 00100bbb01101111 FBBBuuuuuu001000
 
:exth^f32_bit_F f32_B_dst, [f32_C_U6_src]                          is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b001000 & f32_B_dst & f32_bit_F & gen4_f32_B_dst_ZN) ... & f32_C_U6_src{
  f32_B_dst = zext(f32_C_U6_src:2);
  
  build gen4_f32_B_dst_ZN;
}

:exth^f32_bit_F f32_B_dst, [f32_C_U6_src]                          is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b001000 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_B_dst & f32_bit_F) ... & f32_C_U6_src{
  local dest:4 = zext(f32_C_U6_src:2); 
  UPDATE_FLAGS_ZN(dest); 
}

# --------------------------------------------- FLAG ---------------------------------------------
# dop
# FLAG      c   00100rrr00101001 0RRRCCCCCCRRRRRR
# FLAG      u6  00100rrr01101001 0RRRuuuuuuRRRRRR
# FLAG      s12 00100rrr10101001 0RRRssssssSSSSSS
# FLAG<.cc> c   00100rrr11101001 0RRRCCCCCC0QQQQQ
# FLAG<.cc> u6  00100rrr11101001 0RRRuuuuuu1QQQQQ

:flag^f32_cc f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101001 & f32_bit_F=0b0 & f32_cc ) ... & f32_C_U6_S12_src {
	build f32_cc;
	if ~((U == 0) && ((f32_C_U6_S12_src & 1:4) == 1:4)) goto inst_next;
	H = 1;
}

# --------------------------------------------- J ---------------------------------------------
# J     [c] 00100 RRR 00 100000 RRRRCCCCCCRRRRRR
# J     u6  00100 RRR 01 100000 RRRRuuuuuuRRRRRR
# J     s12 00100 RRR 10 100000 RRRRssssssSSSSSS
# Jcc   [c] 00100 RRR 11 100000 RRRRCCCCCC0QQQQQ
# Jcc   u6  00100 RRR 11 100000 RRRRuuuuuu1QQQQQ

# J.D   [c] 00100 RRR 00 100001 RRRRCCCCCCRRRRRR
# J.D   u6  00100 RRR 01 100001 RRRRuuuuuuRRRRRR
# J.D   s12 00100 RRR 10 100001 RRRRssssssSSSSSS
# Jcc.D [c] 00100 RRR 11 100001 RRRRCCCCCC0QQQQQ
# Jcc.D u6  00100 RRR 11 100001 RRRRuuuuuu1QQQQQ

:j^f32_cc     [f32_C_U6_S12_src_for_jump] 	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100000 & f32_cc) ... & f32_C_U6_S12_src_for_jump {
	build f32_cc;
	goto [f32_C_U6_S12_src_for_jump];
}

:j.d^f32_cc [f32_C_U6_S12_src_for_jump] 	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100001 & f32_cc ) ... & f32_C_U6_S12_src_for_jump {
	build f32_cc;
	delayslot(1);
	goto [f32_C_U6_S12_src_for_jump];
}

:j^f32_cc     [f32_C_U6_S12_src_for_jump] 	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100000 & f32_cc & f32_C = 0b011111) ... & f32_C_U6_S12_src_for_jump {
	build f32_cc;
	return [f32_C_U6_S12_src_for_jump];
}

:j.d^f32_cc [f32_C_U6_S12_src_for_jump] 	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100001 & f32_cc & f32_C = 0b011111) ... & f32_C_U6_S12_src_for_jump {
	build f32_cc;
	delayslot(1);
	return [f32_C_U6_S12_src_for_jump];
}

# --------------------------------------------- JL ---------------------------------------------
# JL     [c] 00100RRR00100010 RRRRCCCCCCRRRRRR
# JL     u6  00100RRR01100010 RRRRuuuuuuRRRRRR
# JL     s12 00100RRR10100010 RRRRssssssSSSSSS
# JLcc   [c] 00100RRR11100010 RRRRCCCCCC0QQQQQ
# JLcc   u6  00100RRR11100010 RRRRuuuuuu1QQQQQ

# JL.D   [c] 00100RRR00100011 RRRRCCCCCCRRRRRR
# JL.D   u6  00100RRR01100011 RRRRuuuuuuRRRRRR
# JL.D   s12 00100RRR10100011 RRRRssssssSSSSSS
# JLcc.D [c] 00100RRR11100011 RRRRCCCCCC0QQQQQ
# JLcc.D u6  00100RRR11100011 RRRRuuuuuu1QQQQQ

:jl^f32_cc f32_C_U6_S12_src_for_jump    	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100010 & f32_cc ) ... & f32_C_U6_S12_src_for_jump {
	build f32_cc;
	blink = inst_next;
	call [f32_C_U6_S12_src_for_jump];
}

:jl.d^f32_cc f32_C_U6_S12_src_for_jump 	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100011 & f32_cc ) ... & f32_C_U6_S12_src_for_jump {
	build f32_cc;
	blink = inst_next;
	delayslot(1);
	call [f32_C_U6_S12_src_for_jump];
}

# --------------------------------------------- KFLAG ---------------------------------------------
# KFLAG      c   00100RRR00101001 1RRRCCCCCCRRRRRR
# KFLAG      u6  00100RRR01101001 1RRRuuuuuuRRRRRR
# KFLAG      s12 00100RRR10101001 1RRRssssssSSSSSS
# KFLAG<.cc> c   00100RRR11101001 1RRRCCCCCC0QQQQQ
# KFLAG<.cc> u6  00100RRR11101001 1RRRuuuuuu1QQQQQ

:kflag^f32_cc f32_C_U6_S12_src    	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101001 & f32_bit_F=0b1 & f32_cc ) ... & f32_C_U6_S12_src {
  build f32_cc;
  if ~((U == 0) && ((f32_C_U6_S12_src & 1:4) == 1:4)) goto inst_next;
  H = 1;
}

# --------------------------------------------- LD ---------------------------------------------
# LD<zz><.x><.aa><.di> a,[b,c] 00100bbbaa110ZZXDBBBCCCCCCAAAAAA
:ld^f32_gen4_dop_ZZ^f32_gen4_dop_aa^f32_gen4_dop_D f32_A_dst, [f32_B_src, f32_gen4_C_aa_zz_src] is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_bits_19_21=0b110 & f32_A_dst & f32_gen4_dop_ZZ & f32_gen4_dop_aa & f32_gen4_dop_D & f32_gen4_dop_X) ... & ld_f32_gen4_load & ld_f32_gen4_update & f32_B_src & f32_gen4_C_aa_zz_src {
  build ld_f32_gen4_load;
  build ld_f32_gen4_update;
}



# --------------------------------------------- LDI ---------------------------------------------
# LDI b,[c]   00100bbb00100110 RBBBCCCCCCRRRRRR
# LDI b,[u6]  00100bbb01100110 RBBBuuuuuuRRRRRR
# LDI b,[s12] 00100bbb10100110 RBBBssssssSSSSSS

:ldi     f32_B_dst, [f32_C_U6_S12_src] 	is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b100110 & f32_B_dst ) ... & f32_C_U6_S12_src {
  local addr:4 = (f32_C_U6_S12_src << 2);
  f32_B_dst = *[AUX_REGS_BASE]:4 addr;  	
}

# --------------------------------------------- LP ---------------------------------------------
# LP<cc> u7  00100RRR11101000 RRRRuuuuuu1QQQQQ
# LP     u7  00100RRR01101000 RRRRuuuuuuRRRRRR
# LP     s13 00100RRR10101000 RRRRssssssSSSSSS

:lp^f32_cc f32_gen4_lp_U7_S13  is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101000 & f32_gen4_lp_U7_S13 & f32_cc [ loopEnd = 1; globalset(f32_gen4_lp_U7_S13, loopEnd); ] {
  build f32_cc;
  LP_START = inst_next;
  LP_END = &f32_gen4_lp_U7_S13;
}

#:lp^f32_cc f32_gen4_lp_U7_S13  is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101000 & f32_gen4_lp_U7_S13 & f32_cc {
#  is_in_loop = 0;
#  build f32_cc;
#  LP_START = inst_next;
#  LP_END = &f32_gen4_lp_U7_S13;
#  is_in_loop = 1;
#}

# --------------------------------------------- LR ---------------------------------------------
# LR b,[c]   00100bbb00101010 RBBBCCCCCCRRRRRR
# LR b,[u6]  00100bbb01101010 RBBBuuuuuuRRRRRR
# LR b,[s12] 00100bbb10101010 RBBBssssssSSSSSS

:lr f32_B_dst, [f32_C_U6_S12_src]                          is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101010 & f32_B_dst & f32_bit_F) ... & f32_C_U6_S12_src{
  local addr:4 = (f32_C_U6_S12_src << 2);
  f32_B_dst = *[AUX_REGS_BASE]:4 addr;
}

# --------------------------------------------- LSR ---------------------------------------------
# LSR<.f> b,c  00100bbb00101111FBBBCCCCCC000010
# LSR<.f> b,u6 00100bbb01101111FBBBuuuuuu000010

 
:lsr f32_B_dst, [f32_C_U6_src]              is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000010 & f32_B_dst & f32_bit_F=0b0) ... & f32_C_U6_src{
  f32_B_dst = f32_C_U6_src >> 1;
}

:lsr.f f32_B_dst, [f32_C_U6_src]              is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000010 & f32_B_dst & f32_bit_F=0b1) ... & f32_C_U6_src{
  f32_B_dst = f32_C_U6_src >> 1;
  
  UPDATE_FLAGS_ZN(f32_B_dst);
  C = (f32_C_U6_src[0,1] == 1:1);
}

:lsr^f32_bit_F f32_B_dst, [f32_C_U6_src]              is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_bits_16_21=0b101111 & f32_gen4_sop_i=0b000010 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_B_dst & f32_bit_F) ... & f32_C_U6_src{
	local dest:4 = f32_C_U6_src >> 1;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = (f32_C_U6_src[0,1] == 1:1);
}

# --------------------------------------------- MAX ---------------------------------------------
# MAX<.f>      a,b,c   00100bbb00001000 FBBBCCCCCCAAAAAA
# MAX<.f>      a,b,u6  00100bbb01001000 FBBBuuuuuuAAAAAA
# MAX<.f>      b,b,s12 00100bbb10001000 FBBBssssssSSSSSS
# MAX<.cc><.f> b,b,c   00100bbb11001000 FBBBCCCCCC0QQQQQ
# MAX<.cc><.f> b,b,u6  00100bbb11001000 FBBBuuuuuu1QQQQQ

:max^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001000 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local acond:1 = (f32_C_U6_S12_src s>= f32_B_src);
  f32_A_B_dst = f32_B_src*zext(acond == 0:1)+f32_C_U6_S12_src*zext(acond != 0:1);
}

:max^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001000 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local acond:1 = (f32_C_U6_S12_src s>= f32_B_src);
  local dest:4 = f32_B_src*zext(acond == 0:1)+f32_C_U6_S12_src*zext(acond != 0:1);
  local alu:4 = f32_B_src - f32_C_U6_S12_src;
  
  f32_A_B_dst = dest;

  UPDATE_FLAGS_ZN(alu);  
  C = acond;
  V = sborrow(f32_B_src, f32_C_U6_S12_src); 
}

:max^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001000 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local acond:1 = (f32_C_U6_S12_src s>= f32_B_src);
  local dest:4 = f32_B_src*zext(acond == 0:1)+f32_C_U6_S12_src*zext(acond != 0:1);
  local alu:4 = f32_B_src - f32_C_U6_S12_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(alu);  
  C = acond;
  V = sborrow(f32_B_src, f32_C_U6_S12_src); 
}

# --------------------------------------------- MIN ---------------------------------------------
# MIN<.f>      a,b,c   00100bbb00001001 FBBBCCCCCCAAAAAA
# MIN<.f>      a,b,u6  00100bbb01001001 FBBBuuuuuuAAAAAA
# MIN<.f>      b,b,s12 00100bbb10001001 FBBBssssssSSSSSS
# MIN<.cc><.f> b,b,c   00100bbb11001001 FBBBCCCCCC0QQQQQ
# MIN<.cc><.f> b,b,u6  00100bbb11001001 FBBBuuuuuu1QQQQQ

:min^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001001 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local acond:1 = (f32_C_U6_S12_src s<= f32_B_src);
  f32_A_B_dst = f32_B_src*zext(acond == 0:1)+f32_C_U6_S12_src*zext(acond != 0:1);
}

:min^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001001 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  
  build f32_cc;
  
  local acond:1 = (f32_C_U6_S12_src s<= f32_B_src);
  local dest:4 = f32_B_src*zext(acond == 0:1)+f32_C_U6_S12_src*zext(acond != 0:1);
  local alu:4 = f32_B_src - f32_C_U6_S12_src;
  
  f32_A_B_dst = dest;

  UPDATE_FLAGS_ZN(alu);    
  C = acond;
  V = sborrow(f32_B_src, f32_C_U6_S12_src);
}

:min^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001001 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local acond:1 = (f32_C_U6_S12_src s<= f32_B_src);
  local dest:4 = f32_B_src*zext(acond == 0:1)+f32_C_U6_S12_src*zext(acond != 0:1);
  local alu:4 = f32_B_src - f32_C_U6_S12_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(alu);    
  C = acond;
  V = sborrow(f32_B_src, f32_C_U6_S12_src);
}

# --------------------------------------------- MOV ---------------------------------------------
# dop
# MOV<.f>      b,c   00100bbb00001010 FBBBCCCCCCRRRRRR
# MOV<.f>      b,u6  00100bbb01001010 FBBBuuuuuuRRRRRR
# MOV<.f>      b,s12 00100bbb10001010 FBBBssssssSSSSSS
# MOV<.cc><.f> b,c   00100bbb11001010 FBBBCCCCCC0QQQQQ
# MOV<.cc><.f> b,u6  00100bbb11001010 FBBBuuuuuu1QQQQQ


:mov^f32_cc^f32_bit_F f32_B_dst, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001010 & f32_bit_F & f32_cc & f32_B_dst & gen4_f32_B_dst_ZN) ... & f32_C_U6_S12_src {
  build f32_cc;
  f32_B_dst = f32_C_U6_S12_src;
  build gen4_f32_B_dst_ZN;  
}

:mov^f32_cc^f32_bit_F f32_B_dst, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001010 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_cc & f32_B_dst) ... & f32_C_U6_S12_src {
  build f32_cc;
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(f32_C_U6_S12_src);    
}



# --------------------------------------------- MPY ---------------------------------------------
# MPY<.f>      a,b,c   00100bbb00011010 FBBBCCCCCCAAAAAA
# MPY<.f>      a,b,u6  00100bbb01011010 FBBBuuuuuuAAAAAA
# MPY<.f>      b,b,s12 00100bbb10011010 FBBBssssssSSSSSS
# MPY<.cc><.f> b,b,c   00100bbb11011010 FBBBCCCCCC0QQQQQ
# MPY<.cc><.f> b,b,u6  00100bbb11011010 FBBBuuuuuu1QQQQQ

:mpy^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011010 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = sext(f32_B_src);
  local val_c:8 = sext(f32_C_U6_S12_src);

  local mult:8  = val_b * val_c;

  f32_A_B_dst = mult:4;
}

:mpy^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011010 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = sext(f32_B_src);
  local val_c:8 = sext(f32_C_U6_S12_src);

  local mult:8  = val_b * val_c;

  f32_A_B_dst = mult:4;

  Z = mult:4 == 0:4;
  N = mult[63,1];  
  V = mult[63,1] != mult[62,1];
}

:mpy^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011010 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = sext(f32_B_src);
  local val_c:8 = sext(f32_C_U6_S12_src);

  local mult:8  = val_b * val_c;
  
  if (f32_bit_F == 0:1) goto inst_next;
  Z = mult:4 == 0:4;
  N = mult[63,1];  
  V = mult[63,1] != mult[62,1];
}

# --------------------------------------------- MPYM ---------------------------------------------
# MPYM<.f>      a,b,c   00100bbb00011011FBBBCCCCCCAAAAAA
# MPYM<.f>      a,b,u6  00100bbb01011011FBBBuuuuuuAAAAAA
# MPYM<.f>      b,b,s12 00100bbb10011011FBBBssssssSSSSSS
# MPYM<.cc><.f> b,b,c   00100bbb11011011FBBBCCCCCC0QQQQQ
# MPYM<.cc><.f> b,b,u6  00100bbb11011011FBBBuuuuuu1QQQQQ

:mpym^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011011 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = sext(f32_B_src);
  local val_c:8 = sext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);
  
  f32_A_B_dst = mult(4);
}

:mpym^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011011 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = sext(f32_B_src);
  local val_c:8 = sext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);
  
  f32_A_B_dst = mult(4);

  Z = mult(4) == 0:4;
  N = mult s< 0:8;  
  V = 0:1;  
}

:mpym^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011011 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = sext(f32_B_src);
  local val_c:8 = sext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);
  
  if (f32_bit_F == 0:1) goto inst_next;
  Z = mult(4) == 0:4;
  N = mult s< 0:8;  
  V = 0:1;  
}

# --------------------------------------------- MPYMU ---------------------------------------------
# MPYMU<.f>      a,b,c   00100bbb00011100FBBBCCCCCCAAAAAA
# MPYMU<.f>      a,b,u6  00100bbb01011100FBBBuuuuuuAAAAAA
# MPYMU<.f>      b,b,s12 00100bbb10011100FBBBssssssSSSSSS
# MPYMU<.cc><.f> b,b,c   00100bbb11011100FBBBCCCCCC0QQQQQ
# MPYMU<.cc><.f> b,b,u6  00100bbb11011100FBBBuuuuuu1QQQQQ

:mpymu^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011100 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = zext(f32_B_src);
  local val_c:8 = zext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);
  
  f32_A_B_dst = mult(4);
}

:mpymu^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011100 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = zext(f32_B_src);
  local val_c:8 = zext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);
  
  f32_A_B_dst = mult(4);

  Z = mult(4) == 0:4;
  N = 0:1;
  V = 0:1;
}

:mpymu^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011100 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = zext(f32_B_src);
  local val_c:8 = zext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);
   
  if (f32_bit_F == 0:1) goto inst_next;
  Z = mult(4) == 0:4;
  N = 0:1;
  V = 0:1;
}

# --------------------------------------------- MPYU ---------------------------------------------
# MPYU<.f>      a,b,c   00100bbb00011101FBBBCCCCCCAAAAAA
# MPYU<.f>      a,b,u6  00100bbb01011101FBBBuuuuuuAAAAAA
# MPYU<.f>      b,b,s12 00100bbb10011101FBBBssssssSSSSSS
# MPYU<.cc><.f> b,b,c   00100bbb11011101FBBBCCCCCC0QQQQQ
# MPYU<.cc><.f> b,b,u6  00100bbb11011101FBBBuuuuuu1QQQQQ

:mpyu^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011101 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = zext(f32_B_src);
  local val_c:8 = zext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);

  f32_A_B_dst = mult:4;
}

:mpyu^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011101 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = zext(f32_B_src);
  local val_c:8 = zext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);

  f32_A_B_dst = mult:4;

  Z = mult:4 == 0:4;
  N = 0:1;
  V = mult[63,1] != mult[62,1];
}

:mpyu^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011101 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:8 = zext(f32_B_src);
  local val_c:8 = zext(f32_C_U6_S12_src);

  local mult:8  = (val_b * val_c);

  if (f32_bit_F == 0:1) goto inst_next;
  Z = mult:4 == 0:4;
  N = 0:1;
  V = mult[63,1] != mult[62,1];
}

# --------------------------------------------- MPYUW ---------------------------------------------
# MPYUW<.f>      a,b,c   00100bbb00011111FBBBCCCCCCAAAAAA
# MPYUW<.f>      a,b,u6  00100bbb01011111FBBBuuuuuuAAAAAA
# MPYUW<.f>      b,b,s12 00100bbb10011111FBBBssssssSSSSSS
# MPYUW<.cc><.f> b,b,c   00100bbb11011111FBBBCCCCCC0QQQQQ
# MPYUW<.cc><.f> b,b,u6  00100bbb11011111FBBBuuuuuu1QQQQQ

:mpyuw^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011111 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:4 = zext(f32_B_src:2);
  local val_c:4 = zext(f32_C_U6_S12_src:2);

  local mult:4  = (val_b * val_c);
  
  f32_A_B_dst = mult;
}

:mpyuw^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011111 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:4 = zext(f32_B_src:2);
  local val_c:4 = zext(f32_C_U6_S12_src:2);

  local mult:4  = (val_b * val_c);
  
  f32_A_B_dst = mult;

  Z = mult == 0:4;
  N = 0:1;
  V = 0:1;
}

:mpyuw^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011111 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:4 = zext(f32_B_src:2);
  local val_c:4 = zext(f32_C_U6_S12_src:2);

  local mult:4  = (val_b * val_c);
  
  if (f32_bit_F == 0:1) goto inst_next;
  Z = mult == 0:4;
  N = 0:1;
  V = 0:1;
}

# --------------------------------------------- MPYW ---------------------------------------------
# MPYW<.f>      a,b,c   00100bbb00011110FBBBCCCCCCAAAAAA
# MPYW<.f>      a,b,u6  00100bbb01011110FBBBuuuuuuAAAAAA
# MPYW<.f>      b,b,s12 00100bbb10011110FBBBssssssSSSSSS
# MPYW<.cc><.f> b,b,c   00100bbb11011110FBBBCCCCCC0QQQQQ
# MPYW<.cc><.f> b,b,u6  00100bbb11011110FBBBuuuuuu1QQQQQ

:mpyw^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011110 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:4 = sext(f32_B_src:2);
  local val_c:4 = sext(f32_C_U6_S12_src:2);

  local mult:4  = (val_b * val_c);

  f32_A_B_dst = mult;
}

:mpyw^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011110 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:4 = sext(f32_B_src:2);
  local val_c:4 = sext(f32_C_U6_S12_src:2);

  local mult:4  = (val_b * val_c);

  f32_A_B_dst = mult;

  UPDATE_FLAGS_ZN(mult);
  V = sborrow(f32_B_src, f32_C_U6_S12_src); 
}

:mpyw^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011110 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local val_b:4 = sext(f32_B_src:2);
  local val_c:4 = sext(f32_C_U6_S12_src:2);

  local mult:4  = (val_b * val_c);
 
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(mult);
  V = sborrow(f32_B_src, f32_C_U6_S12_src); 
}

# --------------------------------------------- NEG ---------------------------------------------
# NEG<.f>      a,b      00100bbb01001110FBBB000000AAAAAA
# NEG<.cc><.f> b,b      00100bbb11001110FBBB0000001QQQQQ
# RSUB<.f>     a,b,u6   00100bbb01001110FBBBuuuuuuAAAAAA
# NEG and RSUB with U=0 are the same commands

:neg^f32_cc f32_A_B_dst, f32_B_src           is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001110 & f32_C=0b000000 & f32_bit_F=0b0 & f32_A_B_dst & f32_cc) ... & f32_B_src{
  build f32_cc;
  f32_A_B_dst = 0 - f32_B_src;
}

:neg^f32_cc^".f" f32_A_B_dst, f32_B_src           is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001110 & f32_C=0b000000 & f32_bit_F=0b1 & f32_A_B_dst & f32_cc) ... & f32_B_src{
  build f32_cc;
  f32_A_B_dst = 0 - f32_B_src;

  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = f32_A_B_dst s< 0;
  V = sborrow(0, f32_B_src);
}

:neg^f32_bit_F^f32_cc f32_A_B_dst, f32_B_src           is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001110 & f32_C=0b000000 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_A_B_dst & f32_cc) ... & f32_B_src{
  build f32_cc;
  local dest:4 = 0 - f32_B_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = dest s< 0;
  V = sborrow(0, f32_B_src);
}

# --------------------------------------------- NOP ---------------------------------------------
:nop is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001010 & f32_B0_b_0_2=0b110 & f32_bits_22_23=0b01 & f32_bit_F=0b0 & f32_B_3_5=0b111 & f32_gen4_dop_S_6_11=0b000000 & f32_gen4_dop_S_5_0=0b000000 {
  
}

# --------------------------------------------- NOT ---------------------------------------------
# NOT<.f> b,c  00100bbb00101111FBBBCCCCCC001010
# NOT<.f> b,u6 00100bbb01101111FBBBuuuuuu001010

:not^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001010 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F & f32_B_dst & gen4_f32_B_dst_ZN) ... & f32_C_U6_src {
  f32_B_dst = ~f32_C_U6_src;
  
  build gen4_f32_B_dst_ZN; 
}

:not^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001010 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = ~f32_C_U6_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);   
}

# --------------------------------------------- OR ---------------------------------------------
# OR<.f>      a,b,c   00100bbb00000101FBBBCCCCCCAAAAAA
# OR<.f>      a,b,u6  00100bbb01000101FBBBuuuuuuAAAAAA
# OR<.f>      b,b,s12 00100bbb10000101FBBBssssssSSSSSS
# OR<.cc><.f> b,b,c   00100bbb11000101FBBBCCCCCC0QQQQQ
# OR<.cc><.f> b,b,u6  00100bbb11000101FBBBuuuuuu1QQQQQ

:or^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000101 & f32_bit_F & f32_cc & f32_A_B_dst & gen4_f32_A_B_dst_ZN) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src | f32_C_U6_S12_src;
 
  build gen4_f32_A_B_dst_ZN; 
}

:or^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000101 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src | f32_C_U6_S12_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
}

# --------------------------------------------- RCMP ---------------------------------------------
# RCMP      b,c   00100bbb000011011BBBCCCCCCRRRRRR
# RCMP      b,u6  00100bbb010011011BBBuuuuuuRRRRRR
# RCMP      b,s12 00100bbb100011011BBBssssssSSSSSS
# RCMP<.cc> b,c   00100bbb110011011BBBCCCCCC0QQQQQ
# RCMP<.cc> b,u6  00100bbb110011011BBBuuuuuu1QQQQQ

:rcmp^f32_cc f32_B_dst, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001101 & f32_bit_F=0b1 & f32_cc & f32_B_dst) ... & f32_C_U6_S12_src {
  build f32_cc;
	
  local dest:4 = f32_C_U6_S12_src - f32_B_dst;
  
  UPDATE_FLAGS_ZN(dest); 
  C = f32_B_dst < f32_C_U6_S12_src;
  V = sborrow(f32_B_dst, f32_C_U6_S12_src);
}

# --------------------------------------------- RLC ---------------------------------------------
# RLC<.f> b,c  00100bbb00101111FBBBCCCCCC001011
# RLC<.f> b,u6 00100bbb01101111FBBBuuuuuu001011

:rlc f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src << 1) | zext(C);
}

:rlc.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src << 1) | zext(C);
  
  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src s< 0;
}

:rlc^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = (f32_C_U6_src << 1) | zext(C);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src s< 0;
}

# --------------------------------------------- ROL ---------------------------------------------
# ROL<.f> b,c  00100bbb00101111FBBBCCCCCC001101
# ROL<.f> b,u6 00100bbb01101111FBBBuuuuuu001101

:rol f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src << 1) | (f32_C_U6_src >> 31);
}

:rol.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src << 1) | (f32_C_U6_src >> 31);
  
  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src s< 0;
}

:rol^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b001101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = (f32_C_U6_src << 1) | (f32_C_U6_src >> 31);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src s< 0;
}

# --------------------------------------------- ROR ---------------------------------------------
# ROR<.f> b,c  00100bbb00101111FBBBCCCCCC000011
# ROR<.f> b,u6 00100bbb01101111FBBBuuuuuu000011

:ror f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 1) | (f32_C_U6_src << 31);   
}

:ror.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 1) | (f32_C_U6_src << 31);
    
  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src:1 & 1:1;   
}

:ror^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = (f32_C_U6_src >> 1) | (f32_C_U6_src << 31);
    
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src:1 & 1:1;   
}

# --------------------------------------------- RRC ---------------------------------------------
# RRC<.f> b,c  00100bbb00101111FBBBCCCCCC000100
# RRC<.f> b,u6 00100bbb01101111FBBBuuuuuu000100

:rrc f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000100 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 1) | (zext(C) << 31);
}

:rrc.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000100 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 1) | (zext(C) << 31);

  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src:1 & 1:1;
}

:rrc^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000100 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = (f32_C_U6_src >> 1) | (zext(C) << 31);
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src:1 & 1:1;
}

# --------------------------------------------- RSUB ---------------------------------------------
# RSUB<.f>      a,b,c   00100bbb00001110FBBBCCCCCCAAAAAA
# RSUB<.f>      a,b,u6  00100bbb01001110FBBBuuuuuuAAAAAA
# RSUB<.f>      b,b,s12 00100bbb10001110FBBBssssssSSSSSS
# RSUB<.cc><.f> b,b,c   00100bbb11001110FBBBCCCCCC0QQQQQ
# RSUB<.cc><.f> b,b,u6  00100bbb11001110FBBBuuuuuu1QQQQQ

:rsub^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001110 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_C_U6_S12_src - f32_B_src;
}

:rsub^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001110 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_C_U6_S12_src - f32_B_src;
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);  
  C = f32_B_src < f32_C_U6_S12_src;
  V = sborrow(f32_B_src, f32_C_U6_S12_src);
}

:rsub^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001110 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_C_U6_S12_src - f32_B_src;

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
  C = f32_B_src < f32_C_U6_S12_src;
  V = sborrow(f32_B_src, f32_C_U6_S12_src);
}

# --------------------------------------------- RTIE ---------------------------------------------
:rtie is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101111 & f32_B0_b_0_2=0b100 & f32_bits_22_23=0b01 & f32_bit_F=0b0 & f32_B_3_5=0b000 & f32_gen4_dop_S_6_11=0b111111 & f32_gen4_dop_S_5_0 {
  
}

# --------------------------------------------- SBC ---------------------------------------------
# SBC<.f>      a,b,c   00100bbb00000011FBBBCCCCCCAAAAAA
# SBC<.f>      a,b,u6  00100bbb01000011FBBBuuuuuuAAAAAA
# SBC<.f>      b,b,s12 00100bbb10000011FBBBssssssSSSSSS
# SBC<.cc><.f> b,b,c   00100bbb11000011FBBBCCCCCC0QQQQQ
# SBC<.cc><.f> b,b,u6  00100bbb11000011FBBBuuuuuu1QQQQQ

:sbc^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000011 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = (f32_C_U6_S12_src - f32_B_src) - zext(C);
}

:sbc^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000011 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = (f32_C_U6_S12_src - f32_B_src) - zext(C);
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);  
  C = (f32_B_src < f32_C_U6_S12_src) | ((f32_C_U6_S12_src - f32_B_src) < zext(C));
  V = sborrow(f32_B_src, f32_C_U6_S12_src) | sborrow((f32_C_U6_S12_src - f32_B_src), zext(C));
}

:sbc^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000011 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = (f32_C_U6_S12_src - f32_B_src) - zext(C);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
  C = (f32_B_src < f32_C_U6_S12_src) | ((f32_C_U6_S12_src - f32_B_src) < zext(C));
  V = sborrow(f32_B_src, f32_C_U6_S12_src) | sborrow((f32_C_U6_S12_src - f32_B_src), zext(C));
}


# --------------------------------------------- SETEQ ---------------------------------------------

# ===================================================================================================
# Sub-opcode 	| iiiiii 	| Instruction mnemonic 	| Description 				| Operand type
# ===================================================================================================
# 0x38 			| 111000 	| SETEQ 				| set if equal 				| Signed or unsigned
# 0x39 			| 111001 	| SETNE 				| set if not equal 			| Signed or unsigned
# 0x3a 			| 111010 	| SETLT 				| set if less than 			| Signed
# 0x3b 			| 111011 	| SETGE 				| set if greater or equal 	| Signed
# 0x3c 			| 111100 	| SETLO 				| set if lower than 		| Unsigned
# 0x3d 			| 111101 	| SETHS 				| set if higher or same 	| Unsigned
# 0x3e 			| 111110 	| SETLE 				| set if less than or equal | Signed
# 0x3f 			| 111111 	| SETGT 				| set if greater than 		| Signed

# SETcc<.f>      a,b,c   00100bbb00iiiiiiFBBBCCCCCCAAAAAA
# SETcc<.f>      a,b,u6  00100bbb01iiiiiiFBBBuuuuuuAAAAAA
# SETcc<.f>      b,b,s12 00100bbb10iiiiiiFBBBssssssSSSSSS
# SETcc<.cc><.f> b,b,c   00100bbb11iiiiiiFBBBCCCCCC0QQQQQ
# SETcc<.cc><.f> b,b,u6  00100bbb11iiiiiiFBBBuuuuuu1QQQQQ

:set^set_rules^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src & set_rules {
  build f32_cc;
  
  build set_rules;
}

:set^set_rules^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src & set_rules & set_rules_flags {
  build f32_cc;
  
  build set_rules;
  
  build set_rules_flags;
}

#:set^set_rules^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src & set_rules & set_rules_flags {
#  build f32_cc;
  
#  build set_rules_flags;
#}


# --------------------------------------------- SETI ---------------------------------------------
:seti f32_C_U6_src           is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b111111 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b000 & f32_B0_b_0_2=0b110 & f32_bit_F=0b0) ... & f32_C_U6_src {
    
}

# --------------------------------------------- SEXB ---------------------------------------------
# SEXB<.f> b,c  00100bbb00101111FBBBCCCCCC000101
# SEXB<.f> b,u6 00100bbb01101111FBBBuuuuuu000101

:sexb f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = sext(f32_C_U6_src:1);
}

:sexb.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = sext(f32_C_U6_src:1);

  UPDATE_FLAGS_ZN(f32_B_dst);
}

:sexb^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = sext(f32_C_U6_src:1);

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- SEXH ---------------------------------------------
# SEXH<.f> b,c  00100bbb00101111FBBBCCCCCC000110
# SEXH<.f> b,u6 00100bbb01101111FBBBuuuuuu000110

:sexh f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000110 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = sext(f32_C_U6_src:2); 
}

:sexh.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000110 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = sext(f32_C_U6_src:2);

  UPDATE_FLAGS_ZN(f32_B_dst);  
}

:sexh^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b000110 & f32_gen4_sop_bits_16_21=0b101111 & f32_bits_22_23=0b00 & f32_B_3_5=0b111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = sext(f32_C_U6_src:2);

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
}

# --------------------------------------------- SLEEP ---------------------------------------------
# SLEEP c    00100001001011110000CCCCCC111111
# SLEEP <u6> 00100001011011110000uuuuuu111111
:sleep f32_C_U6_src           is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b111111 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b000 & f32_B0_b_0_2=0b001 & f32_bit_F=0b0) ... & f32_C_U6_src {
    
}

# --------------------------------------------- SR ---------------------------------------------
# SR b,[c]
# SR b,[u6]  00100bbb01101011RBBBuuuuuuRRRRRR
# SR b,[s12] 00100bbb10101011RBBBssssssSSSSSS
f32_aux_C_U6_S12_src: limm      is f32_C=0b111110 		& (f32_bits_22_23=0b00 | (f32_bits_22_23=0b11 & f32_bit5=0b0)); limm 																			{ local value:4 = limm << 2; export *[const]:4 value; }
f32_aux_C_U6_S12_src: f32_C    	is f32_C 				& (f32_bits_22_23=0b00 | (f32_bits_22_23=0b11 & f32_bit5=0b0))          																		{ local value:4 = f32_C << 2; export *[const]:4 value; }
f32_aux_C_U6_S12_src: value  	is f32_gen4_dop_U6 		& (f32_bits_22_23=0b01 | (f32_bits_22_23=0b11 & f32_bit5=0b1))       	[ value = f32_gen4_dop_U6 << 2;]										{ export *[const]:4 value; }
f32_aux_C_U6_S12_src: value  	is f32_gen4_dop_S_6_11 	& f32_gen4_dop_S_5_0 & f32_bits_22_23=0b10            					[ value = (f32_gen4_dop_S_6_11 << 8) + (f32_gen4_dop_S_5_0 << 2);]      { export *[const]:4 value; }

:sr f32_B_src, [f32_aux_C_U6_S12_src]          is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101011) ... & f32_B_src & f32_aux_C_U6_S12_src {
  *[AUX_REGS_BASE]:4 (f32_aux_C_U6_S12_src:4) = f32_B_src;
}

:sr.lp_end f32_B_src, [f32_C_U6_S12_src]   is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101011 & f32_gen4_dop_U6=0b000011 & (f32_bits_22_23=0b01 | (f32_bits_22_23=0b11 & f32_bit5=0b1))) ... & f32_B_src & f32_C_U6_S12_src [loopEnd = 1; globalset(f32_B_src, loopEnd);]{
  LP_END = f32_B_src;
}

:sr.lp_end f32_B_src, [f32_C_U6_S12_src]   is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101011 & f32_gen4_dop_S_6_11=0b000000 & f32_gen4_dop_S_5_0=0b000011 & f32_bits_22_23=0b10) ... & f32_B_src & f32_C_U6_S12_src [loopEnd = 1; globalset(f32_B_src, loopEnd);]{
  LP_END = f32_B_src;
}

:sr.lp_start f32_B_src, [f32_C_U6_S12_src] is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101011 & f32_gen4_dop_U6=0b000010 & (f32_bits_22_23=0b01 | (f32_bits_22_23=0b11 & f32_bit5=0b1))) ... & f32_B_src & f32_C_U6_S12_src  {
  LP_START = f32_B_src;
}

:sr.lp_start f32_B_src, [f32_C_U6_S12_src] is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101011 & f32_gen4_dop_S_6_11=0b000000 & f32_gen4_dop_S_5_0=0b000010 & f32_bits_22_23=0b10) ... & f32_B_src & f32_C_U6_S12_src {
  LP_START = f32_B_src;
}


# --------------------------------------------- SUB ---------------------------------------------
# SUB<.f>      a,b,c   00100bbb00000010 FBBBCCCCCCAAAAAA
# SUB<.f>      a,b,u6  00100bbb01000010 FBBBuuuuuuAAAAAA
# SUB<.f>      b,b,s12 00100bbb10000010 FBBBssssssSSSSSS
# SUB<.cc><.f> b,b,c   00100bbb11000010 FBBBCCCCCC0QQQQQ
# SUB<.cc><.f> b,b,u6  00100bbb11000010 FBBBuuuuuu1QQQQQ

:sub^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000010 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - f32_C_U6_S12_src;
}

:sub^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000010 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - f32_C_U6_S12_src;
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = f32_B_src < f32_C_U6_S12_src;
  V = sborrow(f32_B_src, f32_C_U6_S12_src);
}

:sub^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000010 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src - f32_C_U6_S12_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_B_src < f32_C_U6_S12_src;
  V = sborrow(f32_B_src, f32_C_U6_S12_src);
}

# --------------------------------------------- SUB1 ---------------------------------------------
# SUB1<.f>      a,b,c   00100bbb00010111 FBBBCCCCCCAAAAAA
# SUB1<.f>      a,b,u6  00100bbb01010111 FBBBuuuuuuAAAAAA
# SUB1<.f>      b,b,s12 00100bbb10010111 FBBBssssssSSSSSS
# SUB1<.cc><.f> b,b,c   00100bbb11010111 FBBBCCCCCC0QQQQQ
# SUB1<.cc><.f> b,b,u6  00100bbb11010111 FBBBuuuuuu1QQQQQ

:sub1^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010111 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - (f32_C_U6_S12_src << 1);
}

:sub1^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010111 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - (f32_C_U6_S12_src << 1);

  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = (f32_B_src < (f32_C_U6_S12_src << 1)) 		| carry(f32_C_U6_S12_src, f32_C_U6_S12_src);
  V = sborrow(f32_B_src, (f32_C_U6_S12_src << 1)) 	| scarry(f32_C_U6_S12_src, f32_C_U6_S12_src);
}

:sub1^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b010111 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src - (f32_C_U6_S12_src << 1);
   
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = (f32_B_src < (f32_C_U6_S12_src << 1)) 		| carry(f32_C_U6_S12_src, f32_C_U6_S12_src);
  V = sborrow(f32_B_src, (f32_C_U6_S12_src << 1)) 	| scarry(f32_C_U6_S12_src, f32_C_U6_S12_src);
}

# --------------------------------------------- SUB2 ---------------------------------------------
# SUB2<.f>      a,b,c   00100bbb00011000FBBBCCCCCCAAAAAA
# SUB2<.f>      a,b,u6  00100bbb01011000FBBBuuuuuuAAAAAA
# SUB2<.f>      b,b,s12 00100bbb10011000FBBBssssssSSSSSS
# SUB2<.cc><.f> b,b,c   00100bbb11011000FBBBCCCCCC0QQQQQ
# SUB2<.cc><.f> b,b,u6  00100bbb11011000FBBBuuuuuu1QQQQQ

:sub2^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011000 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - (f32_C_U6_S12_src << 2);
}

:sub2^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011000 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - (f32_C_U6_S12_src << 2);
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = 		 (f32_B_src < (f32_C_U6_S12_src << 2)) 	|  carry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	|  carry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1);
  V = sborrow(f32_B_src, (f32_C_U6_S12_src << 2)) 	| scarry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	| scarry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1);
}

:sub2^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011000 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src - (f32_C_U6_S12_src << 2);
   
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = 		 (f32_B_src < (f32_C_U6_S12_src << 2)) 	|  carry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	|  carry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1);
  V = sborrow(f32_B_src, (f32_C_U6_S12_src << 2)) 	| scarry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	| scarry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1);
}

# --------------------------------------------- SUB3 ---------------------------------------------
# SUB3<.f>      a,b,c   00100bbb00011001FBBBCCCCCCAAAAAA
# SUB3<.f>      a,b,u6  00100bbb01011001FBBBuuuuuuAAAAAA
# SUB3<.f>      b,b,s12 00100bbb10011001FBBBssssssSSSSSS
# SUB3<.cc><.f> b,b,c   00100bbb11011001FBBBCCCCCC0QQQQQ
# SUB3<.cc><.f> b,b,u6  00100bbb11011001FBBBuuuuuu1QQQQQ

:sub3^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011001 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - (f32_C_U6_S12_src << 2);  
}

:sub3^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011001 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  f32_A_B_dst = f32_B_src - (f32_C_U6_S12_src << 2);
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = 		 (f32_B_src < (f32_C_U6_S12_src << 2)) 	|  carry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	|  carry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1)	|  carry(f32_C_U6_S12_src << 2, f32_C_U6_S12_src << 2);
  V = sborrow(f32_B_src, (f32_C_U6_S12_src << 2)) 	| scarry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	| scarry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1)	| scarry(f32_C_U6_S12_src << 2, f32_C_U6_S12_src << 2);
}

:sub3^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b011001 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local dest:4 = f32_B_src - (f32_C_U6_S12_src << 2);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = 		 (f32_B_src < (f32_C_U6_S12_src << 2)) 	|  carry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	|  carry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1)	|  carry(f32_C_U6_S12_src << 2, f32_C_U6_S12_src << 2);
  V = sborrow(f32_B_src, (f32_C_U6_S12_src << 2)) 	| scarry(f32_C_U6_S12_src, f32_C_U6_S12_src) 	| scarry(f32_C_U6_S12_src << 1, f32_C_U6_S12_src << 1)	| scarry(f32_C_U6_S12_src << 2, f32_C_U6_S12_src << 2);
}

# --------------------------------------------- SWI ---------------------------------------------
# SWI 00100010011011110000RRRRRR111111
:swi is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101111 & f32_B0_b_0_2=0b010 & f32_bits_22_23=0b01 & f32_bit_F=0b0 & f32_B_3_5=0b000 & f32_gen4_dop_S_6_11=0b111111 & f32_gen4_dop_S_5_0 {
  
}

# --------------------------------------------- SYNC ---------------------------------------------
# SYNC 00100011011011110000RRRRRR11111
:sync is F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101111 & f32_B0_b_0_2=0b011 & f32_bits_22_23=0b01 & f32_bit_F=0b0 & f32_B_3_5=0b000 & f32_gen4_dop_S_6_11=0b111111 & f32_gen4_dop_S_5_0 {
  
}

# --------------------------------------------- TST ---------------------------------------------
# TST      b,c   00100bbb000010111BBBCCCCCCRRRRRR
# TST      b,u6  00100bbb010010111BBBuuuuuuRRRRRR
# TST      b,s12 00100bbb100010111BBBssssssSSSSSS
# TST<.cc> b,c   00100bbb110010111BBBCCCCCC0QQQQQ
# TST<.cc> b,u6  00100bbb110010111BBBuuuuuu1QQQQQ

:tst^f32_cc f32_B_dst, f32_C_U6_S12_src              is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b001011 & f32_bit_F=0b1 & f32_cc & f32_B_dst) ... & f32_C_U6_S12_src {
	build f32_cc;
	local alu:4 = f32_B_dst & f32_C_U6_S12_src;
	UPDATE_FLAGS_ZN(alu);
}

# --------------------------------------------- WEVT ---------------------------------------------
# WEVT c    00100000001011110001CCCCCC111111
# WEVT <u6> 00100000011011110001uuuuuu111111
:wevt f32_C_U6_src           is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_sop_i=0b111111 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b001 & f32_B0_b_0_2=0b000 & f32_bit_F=0b0) ... & f32_C_U6_src {
    
}

# --------------------------------------------- XBFU ---------------------------------------------
# XBFU<.f>      a,b,c   00100bbb00101101FBBBCCCCCCAAAAAA
# XBFU<.f>      a,b,u6  00100bbb01101101FBBBuuuuuuAAAAAA
# XBFU<.f>      b,b,s12 00100bbb10101101FBBBssssssSSSSSS
# XBFU<.cc><.f> b,b,c   00100bbb11101101FBBBCCCCCC0QQQQQ
# XBFU<.cc><.f> b,b,u6  00100bbb11101101FBBBuuuuuu1QQQQQ

:xbfu^f32_cc f32_A_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101101 & f32_bit_F=0b0 & f32_cc & f32_A_dst) ... & f32_B_src & f32_C_U6_S12_src {
	build f32_cc;
	
	local loc_M:4 = zext(f32_C_U6_S12_src[0,5]);
	local loc_N:4 = zext(f32_C_U6_S12_src[5,5]) + 1:4;
	f32_A_dst = (f32_B_src >> loc_N) & ((1:4 << loc_M) - 1:4);
}

:xbfu^f32_cc^".f" f32_A_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101101 & f32_bit_F=0b1 & f32_cc & f32_A_dst) ... & f32_B_src & f32_C_U6_S12_src {
	build f32_cc;
	
	local loc_M:4 = zext(f32_C_U6_S12_src[0,5]);
	local loc_N:4 = zext(f32_C_U6_S12_src[5,5]) + 1:4;
	f32_A_dst = (f32_B_src >> loc_N) & ((1:4 << loc_M) - 1:4);

  Z = (f32_A_dst == 0);
}


:xbfu^f32_cc^f32_bit_F f32_A_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b101101 & f32_A=0b111110 & f32_bit_F & f32_cc & f32_A_dst) ... & f32_B_src & f32_C_U6_S12_src {
	build f32_cc;
	
	local loc_M:4 = zext(f32_C_U6_S12_src[0,5]);
	local loc_N:4 = zext(f32_C_U6_S12_src[5,5]) + 1:4;
	local dest:4 = (f32_B_src >> loc_N) & ((1:4 << loc_M) - 1:4);
  
  if (f32_bit_F == 0:1) goto inst_next;
  Z = (dest == 0);
}

# --------------------------------------------- XOR ---------------------------------------------
# XOR<.f>      a,b,c   00100bbb00000111FBBBCCCCCCAAAAAA
# XOR<.f>      a,b,u6  00100bbb01000111FBBBuuuuuuAAAAAA
# XOR<.f>      b,b,s12 00100bbb10000111FBBBssssssSSSSSS
# XOR<.cc><.f> b,b,c   00100bbb11000111FBBBCCCCCC0QQQQQ
# XOR<.cc><.f> b,b,u6  00100bbb11000111FBBBuuuuuu1QQQQQ

:xor^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000111 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src ^ f32_C_U6_S12_src;
}

:xor^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000111 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src ^ f32_C_U6_S12_src;
  
  UPDATE_FLAGS_ZN(f32_A_B_dst); 
}

:xor^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_GEN4) & f32_gen4_dop_i=0b000111 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local dest:4 = f32_B_src ^ f32_C_U6_S12_src;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest); 
}

# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F32_EXT5 001001
# ***********************************************************************************************
# ***********************************************************************************************

# --------------------------------------------- ASL ---------------------------------------------
# ASL<.f>      a,b,c   00101bbb00000000FBBBCCCCCCAAAAAA
# ASL<.f>      a,b,u6  00101bbb01000000FBBBuuuuuuAAAAAA
# ASL<.f>      b,b,s12 00101bbb10000000FBBBssssssSSSSSS
# ASL<.cc><.f> b,b,c   00101bbb11000000FBBBCCCCCC0QQQQQ
# ASL<.cc><.f> b,b,u6  00101bbb11000000FBBBuuuuuu1QQQQQ
:asl^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000000 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src << (f32_C_U6_S12_src & 31);
}

:asl^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000000 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src << (f32_C_U6_S12_src & 31);
  
  UPDATE_FLAGS_ZN(f32_A_B_dst); 
  C = f32_A_B_dst[31,1];
}

:asl^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000000 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc; 
  local dest:4 = f32_B_src << (f32_C_U6_S12_src & 31);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest); 
  C = dest[31,1];
}

# --------------------------------------------- ASR ---------------------------------------------
# ASR<.f>      a,b,c   00101bbb00000010FBBBCCCCCCAAAAAA
# ASR<.f>      a,b,u6  00101bbb01000010FBBBuuuuuuAAAAAA
# ASR<.f>      b,b,s12 00101bbb10000010FBBBssssssSSSSSS
# ASR<.cc><.f> b,b,c   00101bbb11000010FBBBCCCCCC0QQQQQ
# ASR<.cc><.f> b,b,u6  00101bbb11000010FBBBuuuuuu1QQQQQ

:asr^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000010 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src s>> (f32_C_U6_S12_src & 31);
}

:asr^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000010 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  f32_A_B_dst = f32_B_src s>> (f32_C_U6_S12_src & 31);
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);  
  C = f32_A_B_dst[31,1];
}

:asr^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000010 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local dest:4 = f32_B_src s>> (f32_C_U6_S12_src & 31);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
  C = dest[31,1];
}

# --------------------------------------------- ASR16 ---------------------------------------------
# ASR16<.f> b,c  00101bbb00101111FBBBCCCCCC001100
# ASR16<.f> b,u6 00101bbb01101111FBBBuuuuuu001100

:asr16 f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001100 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src s>> 16;
  if f32_C_U6_src s>= 0:4 goto <next>;
  f32_B_dst = f32_B_dst | 0xFFFF0000:4;
<next> 
}

:asr16.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001100 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src s>> 16;
  if f32_C_U6_src s>= 0:4 goto <next>;
  f32_B_dst = f32_B_dst | 0xFFFF0000:4;
<next>
  
  UPDATE_FLAGS_ZN(f32_B_dst);  
}

:asr16^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001100 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src s>> 16;
  if f32_C_U6_src s>= 0:4 goto <next>;
  dest = dest | 0xFFFF0000:4;
<next>
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
}

# --------------------------------------------- ASR8 ---------------------------------------------
# ASR8<.f> b,c  00101bbb00101111FBBBCCCCCC001101
# ASR8<.f> b,u6 00101bbb01101111FBBBuuuuuu001101
:asr8 f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src s>> 8;
  if f32_C_U6_src s>= 0:4 goto <next>;
  f32_B_dst = f32_B_dst | 0xFF000000:4;
<next>
}

:asr8.f f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001101 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src s>> 8;
  if f32_C_U6_src s>= 0:4 goto <next>;
  f32_B_dst = f32_B_dst | 0xFF000000:4;
<next>
  
  UPDATE_FLAGS_ZN(f32_B_dst);  
}

:asr8^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001101 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src s>> 8;
  if f32_C_U6_src s>= 0:4 goto <next>;
  dest = dest | 0xFF000000:4;
<next>
   
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
}

# --------------------------------------------- BSPEEK ---------------------------------------------
# BSPEEK<.F> b,c  00101bbb00101111FBBBCCCCCC101110
# BSPEEK<.F> b,u6 00101bbb01101111FBBBuuuuuu101110
:bspeek^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b101110 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
    
}

# --------------------------------------------- BSPOP ---------------------------------------------
# BSPOP<.F> b,c  00101bbb00101111FBBBCCCCCC101111
# BSPOP<.F> b,u6 00101bbb01101111FBBBuuuuuu101111
:bspop^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b101111 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
    
}

# --------------------------------------------- BSPUSH ---------------------------------------------
# BSPUSH      a,b,c   00101bbb00101110 1BBBCCCCCCAAAAAA
# BSPUSH      a,b,u6  00101bbb01101110 1BBBuuuuuuAAAAAA
# BSPUSH      b,b,s12 00101bbb10101110 1BBBssssssSSSSSS
# BSPUSH<.cc> b,b,c   00101bbb11101110 1BBBCCCCCC0QQQQQ
# BSPUSH<.cc> b,b,u6  00101bbb11101110 1BBBuuuuuu1QQQQQ

:bspush^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b101110 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_B_src & f32_C_U6_S12_src {
  
}

# --------------------------------------------- DIV ---------------------------------------------
# DIV<.f>      a,b,c   00101bbb00000100FBBBCCCCCCAAAAAA
# DIV<.f>      a,b,u6  00101bbb01000100FBBBuuuuuuAAAAAA
# DIV<.f>      b,b,s12 00101bbb10000100FBBBssssssSSSSSS
# DIV<.cc><.f> b,b,c   00101bbb11000100FBBBCCCCCC0QQQQQ
# DIV<.cc><.f> b,b,u6  00101bbb11000100FBBBuuuuuu1QQQQQ

:div^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000100 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  if ((f32_C_U6_S12_src == 0:4) || ((f32_B_src == 0x80000000:4) && f32_C_U6_S12_src == 0xFFFFFFFF:4 )) goto <exception>;
  
  f32_A_B_dst = f32_B_src s/ f32_C_U6_S12_src;

<exception>
}

:div^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000100 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  if ((f32_C_U6_S12_src == 0:4) || ((f32_B_src == 0x80000000:4) && f32_C_U6_S12_src == 0xFFFFFFFF:4 )) goto <exception>;
  
  f32_A_B_dst = f32_B_src s/ f32_C_U6_S12_src;

  UPDATE_FLAGS_ZN(f32_A_B_dst); 
  V = 0;
  goto inst_next;
<exception>
  V = 1;
}

:div^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000100 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  if ((f32_C_U6_S12_src == 0:4) || ((f32_B_src == 0x80000000:4) && f32_C_U6_S12_src == 0xFFFFFFFF:4 )) goto <exception>;
  
  local dest:4 = f32_B_src s/ f32_C_U6_S12_src;

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest); 
  V = 0;
  goto inst_next;
<exception>
  if (f32_bit_F == 0:1) goto inst_next;
  V = 1;
}

# --------------------------------------------- DIVU ---------------------------------------------
# DIVU<.f>      a,b,c   00101bbb00000101FBBBCCCCCCAAAAAA
# DIVU<.f>      a,b,u6  00101bbb01000101FBBBuuuuuuAAAAAA
# DIVU<.f>      b,b,s12 00101bbb10000101FBBBssssssSSSSSS
# DIVU<.cc><.f> b,b,c   00101bbb11000101FBBBCCCCCC0QQQQQ
# DIVU<.cc><.f> b,b,u6  00101bbb11000101FBBBuuuuuu1QQQQQ

:divu^f32_cc^f32_bit_F "NULL", f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000101 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  if (f32_C_U6_S12_src == 0:4) goto <exception>;
  
  local dest:4 = f32_B_src / f32_C_U6_S12_src;

  if (f32_bit_F == 0:1) goto inst_next;
  Z = dest == 0:4;
  N = 0;  
  V = 0;
  goto inst_next;
<exception>
  if (f32_bit_F == 0:1) goto inst_next;
  V = 1;
}


:divu^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000101 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  if (f32_C_U6_S12_src == 0:4) goto <exception>;
  
  f32_A_B_dst = f32_B_src / f32_C_U6_S12_src;

<exception>
}

:divu^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000101 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  if (f32_C_U6_S12_src == 0:4) goto <exception>;
  
  f32_A_B_dst = f32_B_src / f32_C_U6_S12_src;

  Z = f32_A_B_dst == 0:4;
  N = 0;  
  V = 0;
  goto inst_next;
<exception>
  V = 1;
}




# --------------------------------------------- FFS ---------------------------------------------
# FFS<.f> b,c  00101bbb00101111FBBBCCCCCC010010
# FFS<.f> b,u6 00101bbb01101111FBBBuuuuuu010010

:ffs^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010010 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 0;
  local curr_bit = 0;

<loop>    
  curr_bit = (f32_C_U6_src >> dest) & 1:4;
  dest = dest + 1;
  if ((curr_bit == 0:4) && (dest < 33)) goto <loop>;  
    
  dest = dest - 1;
    
  UPDATE_FLAGS_ZN(dest);
}

:ffs^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010010 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 0;
  local curr_bit = 0;

<loop>    
  curr_bit = (f32_C_U6_src >> dest) & 1:4;
  dest = dest + 1;
  if ((curr_bit == 0:4) && (dest < 33)) goto <loop>;  
    
  dest = dest - 1;
    
  f32_B_dst = dest;

  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- FLS ---------------------------------------------
# FLS<.f> b,c  00101bbb00101111FBBBCCCCCC010011
# FLS<.f> b,u6 00101bbb01101111FBBBuuuuuu010011

:fls^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 32;
  local curr_bit = 1:4;

<loop>    
	dest = dest - 1;
  curr_bit = 1:4 >> dest;
    
  if (((dest & curr_bit) != curr_bit) && (dest s> 0)) goto <loop>;  
    
  f32_B_dst = dest;

  UPDATE_FLAGS_ZN(dest);
}

:fls^f32_bit_F f32_B_dst, f32_C_U6_src               is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010011 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 32;
  local curr_bit = 1:4;

<loop>    
	dest = dest - 1;
  curr_bit = 1:4 >> dest;
    
  if (((dest & curr_bit) != curr_bit) && (dest s> 0)) goto <loop>;  
     
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- LSL16 ---------------------------------------------
# LSL16<.f> b,c  00101bbb00101111FBBBCCCCCC001010
# LSL16<.f> b,u6 00101bbb01101111FBBBuuuuuu001010

:lsl16 f32_B_dst, f32_C_U6_src             is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001010 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src << 16;
}

:lsl16.f f32_B_dst, f32_C_U6_src             is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001010 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src << 16;
  
  UPDATE_FLAGS_ZN(f32_B_dst);
}

:lsl16^f32_bit_F f32_B_dst, f32_C_U6_src             is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001010 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src << 16;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- LSL8 ---------------------------------------------
# LSL8<.f> b,c  00101bbb00101111FBBBCCCCCC001111
# LSL8<.f> b,u6 00101bbb01101111FBBBuuuuuu001111

:lsl8 f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001111 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src << 8;
}

:lsl8.f f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001111 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src << 8;
  
  UPDATE_FLAGS_ZN(f32_B_dst);
}

:lsl8^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001111 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src << 8;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- LSR ---------------------------------------------
# LSR<.f>      a,b,c   00101bbb00000001FBBBCCCCCCAAAAAA
# LSR<.f>      a,b,u6  00101bbb01000001FBBBuuuuuuAAAAAA
# LSR<.f>      b,b,s12 00101bbb10000001FBBBssssssSSSSSS
# LSR<.cc><.f> b,b,c   00101bbb11000001FBBBCCCCCC0QQQQQ
# LSR<.cc><.f> b,b,u6  00101bbb11000001FBBBuuuuuu1QQQQQ 

:lsr^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000001 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = (f32_C_U6_S12_src & 31);
  f32_A_B_dst = f32_B_src >> shift;
}

:lsr^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000001 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = (f32_C_U6_S12_src & 31);
  f32_A_B_dst = f32_B_src >> shift;
  
  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = 0;
  
  if (f32_C_U6_S12_src == 0:4) goto inst_next;
  local bit:4 = (f32_B_src >> (shift-1)) & 1:4;
  C = bit:1;
}

:lsr^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000001 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  local shift:4 = (f32_C_U6_S12_src & 31);
  local dest:4 = f32_B_src >> shift;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = 0;
  
  if (f32_C_U6_S12_src == 0:4) goto inst_next;
  local bit:4 = (f32_B_src >> (shift-1)) & 1:4;
  C = bit:1;
}

# --------------------------------------------- LSR16 ---------------------------------------------
# LSR16<.f> b,c  00101bbb00101111FBBBCCCCCC001011
# LSR16<.f> b,u6 00101bbb01101111FBBBuuuuuu001011

:lsr16 f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src >> 16;
}

:lsr16.f f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001011 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src >> 16;
  
  UPDATE_FLAGS_ZN(f32_B_dst);
}

:lsr16^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001011 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src >> 16;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- LSR8 ---------------------------------------------
# LSR8<.f> b,c  00101bbb00101111FBBBCCCCCC001110
# LSR8<.f> b,u6 00101bbb01101111FBBBuuuuuu001110

:lsr8 f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001110 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src >> 8;
}

:lsr8.f f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001110 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = f32_C_U6_src >> 8;
  
  UPDATE_FLAGS_ZN(f32_B_dst);
}

:lsr8^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001110 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = f32_C_U6_src >> 8;
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- NORM ---------------------------------------------
# NORM<.f> b,c  00101bbb00101111FBBBCCCCCC000001
# NORM<.f> b,u6 00101bbb01101111FBBBuuuuuu000001

:norm^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b000001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 32;
  local i = 0:4;

	local acond1 = 0:1;
	local acond2 = 0:1;
	
<loop>    
	acond1 = (f32_C_U6_src s>> i) == 0:4;
	acond2 = (f32_C_U6_src s>> i) == 0xFFFFFFFF:4;
  i = i + 1;
  if ((acond1 == 0:1) && (acond2 == 0:1) && (i<33) ) goto <loop>;  
  
  dest = 32 - i;
  
  f32_B_dst = dest;
  UPDATE_FLAGS_ZN(dest);
}

:norm^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b000001 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 32;
  local i = 0:4;

	local acond1 = 0:1;
	local acond2 = 0:1;
	
<loop>    
	acond1 = (f32_C_U6_src s>> i) == 0:4;
	acond2 = (f32_C_U6_src s>> i) == 0xFFFFFFFF:4;
  i = i + 1;
  if ((acond1 == 0:1) && (acond2 == 0:1) && (i<33) ) goto <loop>;  
  
  dest = 32 - i;
  
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- NORMH ---------------------------------------------
# NORMH<.f> b,c  00101bbb00101111FBBBCCCCCC001000
# NORMH<.f> b,u6 00101bbb01101111FBBBuuuuuu001000

:normh^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001000 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 32;
  local i = 0:4;

  local acond1 = 0:1;
  local acond2 = 0:1;
	
<loop>    
  acond1 = (f32_C_U6_src:2 s>> i) == 0:2;
  acond2 = (f32_C_U6_src:2 s>> i) == 0xFFFF:2;
  i = i + 1;
  if ((acond1 == 0:1) && (acond2 == 0:1) && (i<17) ) goto <loop>;  
  
  dest = 16 - i;
  
  f32_B_dst = dest;
  UPDATE_FLAGS_ZN(dest);
}

:normh^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001000 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest = 32;
  local i = 0:4;

	local acond1 = 0:1;
	local acond2 = 0:1;
	
<loop>    
	acond1 = (f32_C_U6_src:2 s>> i) == 0:2;
	acond2 = (f32_C_U6_src:2 s>> i) == 0xFFFF:2;
  i = i + 1;
  if ((acond1 == 0:1) && (acond2 == 0:1) && (i<17) ) goto <loop>;  
  
  dest = 16 - i;
  UPDATE_FLAGS_ZN(dest);
}

# --------------------------------------------- REM ---------------------------------------------
# REM<.f>      a,b,c   00101bbb00001000FBBBCCCCCCAAAAAA
# REM<.f>      a,b,u6  00101bbb01001000FBBBuuuuuuAAAAAA
# REM<.f>      b,b,s12 00101bbb10001000FBBBssssssSSSSSS
# REM<.cc><.f> b,b,c   00101bbb11001000FBBBCCCCCC0QQQQQ
# REM<.cc><.f> b,b,u6  00101bbb11001000FBBBuuuuuu1QQQQQ

:rem^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b001000 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  if ((f32_C_U6_S12_src == 0:4) || ((f32_B_src == 0x80000000:4) && f32_C_U6_S12_src == 0xFFFFFFFF:4 )) goto <exception>;
  
  f32_A_B_dst = f32_B_src s% f32_C_U6_S12_src;
  goto inst_next;
<exception>

  V = 1;
}

:rem^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b001000 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  if ((f32_C_U6_S12_src == 0:4) || ((f32_B_src == 0x80000000:4) && f32_C_U6_S12_src == 0xFFFFFFFF:4 )) goto <exception>;
  
  f32_A_B_dst = f32_B_src s% f32_C_U6_S12_src;

  UPDATE_FLAGS_ZN(f32_A_B_dst);  
  V = 0;
  goto inst_next;
<exception>
  V = 1;
}



:rem^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b001000 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  if ((f32_C_U6_S12_src == 0:4) || ((f32_B_src == 0x80000000:4) && f32_C_U6_S12_src == 0xFFFFFFFF:4 )) goto <exception>;
  
  local dest:4 = f32_B_src s% f32_C_U6_S12_src;

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);  
  V = 0;
  goto inst_next;
<exception>
  if (f32_bit_F == 0:1) goto inst_next;
  V = 1;
}

# --------------------------------------------- REMU ---------------------------------------------
# REMU<.f>      a,b,c   00101bbb00001001FBBBCCCCCCAAAAAA
# REMU<.f>      a,b,u6  00101bbb01001001FBBBuuuuuuAAAAAA
# REMU<.f>      b,b,s12 00101bbb10001001FBBBssssssSSSSSS
# REMU<.cc><.f> b,b,c   00101bbb11001001FBBBCCCCCC0QQQQQ
# REMU<.cc><.f> b,b,u6  00101bbb11001001FBBBuuuuuu1QQQQQ

:remu^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b001001 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  if ~((f32_C_U6_S12_src != 0:4) && ((f32_B_src != 0x80000000:4) || f32_C_U6_S12_src != 0xFFFFFFFF:4 )) goto <exception>;
  
  f32_A_B_dst = f32_B_src % f32_C_U6_S12_src;

<exception>
}

:remu^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b001001 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  if ~((f32_C_U6_S12_src != 0:4) && ((f32_B_src != 0x80000000:4) || f32_C_U6_S12_src != 0xFFFFFFFF:4 )) goto <exception>;
  
  f32_A_B_dst = f32_B_src % f32_C_U6_S12_src;

  Z = f32_A_B_dst == 0:4;
  N = 0;  
  V = 0;
  goto inst_next;
<exception>

  V = 1;
}

:remu^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b001001 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  if ~((f32_C_U6_S12_src != 0:4) && ((f32_B_src != 0x80000000:4) || f32_C_U6_S12_src != 0xFFFFFFFF:4 )) goto <exception>;
  
  local dest:4 = f32_B_src % f32_C_U6_S12_src;

  if (f32_bit_F == 0:1) goto inst_next;
  Z = dest == 0:4;
  N = 0;  
  V = 0;
  goto inst_next;
<exception>
  if (f32_bit_F == 0:1) goto inst_next;
  V = 1;
}

# --------------------------------------------- ROL8 ---------------------------------------------
# ROL8<.f> b,c  00101bbb00101111FBBBCCCCCC010000
# ROL8<.f> b,u6 00101bbb01101111FBBBuuuuuu010000

:rol8 f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010000 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src << 8) | (f32_C_U6_src >> 24);
}

:rol8.f f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010000 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src << 8) | (f32_C_U6_src >> 24);

  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src s< 0;
}

:rol8^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010000 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = (f32_C_U6_src << 8) | (f32_C_U6_src >> 24);

  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src s< 0;
}

# --------------------------------------------- ROR ---------------------------------------------
# ROR<.f>      a,b,c   00101bbb00000011FBBBCCCCCCAAAAAA
# ROR<.f>      a,b,u6  00101bbb01000011FBBBuuuuuuAAAAAA
# ROR<.f>      b,b,s12 00101bbb10000011FBBBssssssSSSSSS
# ROR<.cc><.f> b,b,c   00101bbb11000011FBBBCCCCCC0QQQQQ
# ROR<.cc><.f> b,b,u6  00101bbb11000011FBBBuuuuuu1QQQQQ

:ror^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000011 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local shift:4 = (f32_C_U6_S12_src & 31);
  
  f32_A_B_dst = (f32_B_src >> shift) | (f32_B_src << (32 - shift));
}

:ror^f32_cc^".f" f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000011 & f32_bit_F=0b1 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local shift:4 = (f32_C_U6_S12_src & 31);
  f32_A_B_dst = (f32_B_src >> shift) | (f32_B_src << (32 - shift));

  UPDATE_FLAGS_ZN(f32_A_B_dst);
  C = 0;
  
  if (f32_C_U6_S12_src == 0:4) goto inst_next;
  local bit:4 = (f32_B_src >> (shift - 1)) & 1:4;
  C = bit:1;
}


:ror^f32_cc^f32_bit_F f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b000011 & (((f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110) | ((f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A=0b111110)) & f32_bit_F & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;
  
  local shift:4 = (f32_C_U6_S12_src & 31);
  local dest:4 = (f32_B_src >> shift) | (f32_B_src << (32 - shift));
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = 0;
  
  if (f32_C_U6_S12_src == 0:4) goto inst_next;
  local bit:4 = (f32_B_src >> (shift - 1)) & 1:4;
  C = bit:1;
}

# --------------------------------------------- ROR8 ---------------------------------------------
# ROR8<.f> b,c  00101bbb00101111FBBBCCCCCC010001
# ROR8<.f> b,u6 00101bbb01101111FBBBuuuuuu010001

:ror8 f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 8) | (f32_C_U6_src << 24);
}

:ror8.f f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 8) | (f32_C_U6_src << 24);
  
  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src s< 0;
}

:ror8^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b010001 & f32_gen4_sop_bits_16_21=0b101111  & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = (f32_C_U6_src >> 8) | (f32_C_U6_src << 24);
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src s< 0;
}

# --------------------------------------------- SJLI ---------------------------------------------
# SJLI u12 00101RRR101000001RRRuuuuuuUUUUUU
:sjli f32_ext_dop_U12 is F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b100000 & f32_bits_22_23=0b10 & f32_bit_F=0b1 & f32_ext_dop_U12 {
  local addr:4 = NSC_TABLE_BASE + f32_ext_dop_U12;
  blink = inst_start + 2;
  goto [addr];
}

# --------------------------------------------- SWAP ---------------------------------------------
# SWAP<.f> b,c  00101bbb00101111FBBBCCCCCC000000
# SWAP<.f> b,u6 00101bbb01101111FBBBuuuuuu000000

:swap f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b000000 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 16) | (f32_C_U6_src << 16);
}

:swap.f f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b000000 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  f32_B_dst = (f32_C_U6_src >> 16) | (f32_C_U6_src << 16);
  
  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src s< 0;
}

:swap^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b000000 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local dest:4 = (f32_C_U6_src >> 16) | (f32_C_U6_src << 16);
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src s< 0;
}

# --------------------------------------------- SWAPE ---------------------------------------------
# SWAPE<.f> b,c  00101bbb00101111FBBBCCCCCC001001
# SWAPE<.f> b,u6 00101bbb01101111FBBBuuuuuu001001

:swape f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b0 & f32_B_dst) ... & f32_C_U6_src {
  local ror8:4 = (f32_C_U6_src >> 8) | (f32_C_U6_src << 24);
  local rol8:4 = (f32_C_U6_src << 8) | (f32_C_U6_src >> 24);
  f32_B_dst = (ror8 & 0xFF00FF00)  | (rol8 & 0x00FF00FF);
}

:swape.f f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001001 & f32_gen4_sop_bits_16_21=0b101111 & f32_bit_F=0b1 & f32_B_dst) ... & f32_C_U6_src {
  local ror8:4 = (f32_C_U6_src >> 8) | (f32_C_U6_src << 24);
  local rol8:4 = (f32_C_U6_src << 8) | (f32_C_U6_src >> 24);
  f32_B_dst = (ror8 & 0xFF00FF00)  | (rol8 & 0x00FF00FF);
  
  UPDATE_FLAGS_ZN(f32_B_dst);
  C = f32_C_U6_src s< 0;
}


:swape^f32_bit_F f32_B_dst, f32_C_U6_src              is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_gen4_sop_i=0b001001 & f32_gen4_sop_bits_16_21=0b101111 & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 & f32_bit_F & f32_B_dst) ... & f32_C_U6_src {
  local ror8:4 = (f32_C_U6_src >> 8) | (f32_C_U6_src << 24);
  local rol8:4 = (f32_C_U6_src << 8) | (f32_C_U6_src >> 24);
  local dest:4 = (ror8 & 0xFF00FF00)  | (rol8 & 0x00FF00FF);
  
  if (f32_bit_F == 0:1) goto inst_next;
  UPDATE_FLAGS_ZN(dest);
  C = f32_C_U6_src s< 0;
}





# ARCv2DSP ISA

#MPYDU<.f>      a,b,c   00101bbb00011001FBBBCCCCCCAAAAAA
#MPYDU<.f>      a,b,u6  00101bbb01011001FBBBuuuuuuAAAAAA
#MPYDU<.f>      b,b,s12 00101bbb10011001FBBBssssssSSSSSS
#MPYDU<.cc><.f> b,b,c   00101bbb11011001FBBBCCCCCC0QQQQQ
#MPYDU<.cc><.f> b,b,u6  00101bbb11011001FBBBuuuuuu1QQQQQ

define register offset=0x00 size=8 [
    RR0  _  RR2  _  RR4  _  RR6  _  RR8  _  RR10       _         RR12             _           RR14         _
    RR16 _  RR18 _  RR20 _  RR22 _  RR24 _  RGP        _         RSP              _           RR30         _
    RR32 _  RR34 _  RR36 _  RR38 _  RR40 _  RR42       _         RR44             _           RR46         _
    RR48 _  RR50 _  RR52 _  RR54 _  RR56 _  RMMID      _    	   RR60_LP_COUNT    _           RR62LIMM     _
];

define register offset=0x04 size=8 [
    RR1  _  RR3  _  RR5  _  RR7  _  RR9  _  RR11       _         RR13             _           RR15         _
    RR17 _  RR19 _  RR21 _  RR23 _  RR25 _  RFP        _         RILINK           _           RBLINK       _
    RR33 _  RR35 _  RR37 _  RR39 _  RR41 _  RR43       _         RR45             _           RR47         _
    RR49 _  RR51 _  RR53 _  RR55 _  RR57 _  RMHI       _    	   _               _           _           _
];


attach variables [ f32_A_ext5 ] [RR0 RR1 RR2 RR3 RR4 RR5 RR6 RR7 RR8 RR9 RR10 RR11 RR12 RR13 RR14 RR15 RR16 RR17 RR18 RR19 RR20 RR21 RR22 RR23 RR24 RR25 RGP RFP RSP RILINK RR30 RBLINK RR32 RR33 RR34
								RR35 RR36 RR37 RR38 RR39 RR40 RR41 RR42 RR43 RR44 RR45 RR46 RR47 RR48 RR49 RR50 RR51 RR52 RR53 RR54 RR55 RR56 RR57 RMMID RMHI RR60_LP_COUNT _ _ _
];
                                  
#f32_ext5_A_B_dst: f32_A_ext5   is (f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A_ext5                 									{ export f32_A_ext5; } 
#f32_ext5_A_B_dst: value 	   is (f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A_ext5=0b111110				 			[value=0;]		{ export *[const]:4 value;}
#f32_ext5_A_B_dst: value        is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0b111 & f32_B7_b_0_2=0b110 	[value=0;]		{ export *[const]:4 value;}
#f32_ext5_A_B_dst: f32_B0_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=0 & f32_B0_b_0_2                 				{ export f32_B0_b_0_2; }
#f32_ext5_A_B_dst: f32_B1_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=1 & f32_B1_b_0_2                 				{ export f32_B1_b_0_2; }
#f32_ext5_A_B_dst: f32_B1_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=1 & f32_B1_b_0_2                 				{ export f32_B1_b_0_2; }
#f32_ext5_A_B_dst: f32_B1_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=1 & f32_B1_b_0_2                 				{ export f32_B1_b_0_2; }
#f32_ext5_A_B_dst: f32_B1_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=1 & f32_B1_b_0_2                 				{ export f32_B1_b_0_2; }
#f32_ext5_A_B_dst: f32_B2_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=2 & f32_B2_b_0_2                 				{ export f32_B2_b_0_2; }
#f32_ext5_A_B_dst: f32_B3_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=3 & f32_B3_b_0_2                 				{ export f32_B3_b_0_2; }
#f32_ext5_A_B_dst: f32_B4_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=4 & f32_B4_b_0_2                 				{ export f32_B4_b_0_2; }
#f32_ext5_A_B_dst: f32_B5_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=5 & f32_B5_b_0_2                 				{ export f32_B5_b_0_2; }
#f32_ext5_A_B_dst: f32_B6_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=6 & f32_B6_b_0_2                 				{ export f32_B6_b_0_2; }
#f32_ext5_A_B_dst: f32_B7_b_0_2 is (f32_bits_22_23=0b10 | f32_bits_22_23=0b11) & f32_B_3_5=7 & f32_B7_b_0_2                 				{ export f32_B7_b_0_2; }

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# p-code is not fully correct
:MPYDU^f32_cc f32_A_ext5, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b011001 & f32_bit_F=0b0 & f32_cc & (f32_bits_22_23=0b00 | f32_bits_22_23=0b01) & f32_A_ext5) ... & f32_C_U6_S12_src & f32_B_src {
  local val_b:8 = zext(f32_B_src);
  local val_c:8 = zext(f32_C_U6_S12_src);

  local mult:8  = val_b * val_c;

  f32_A_ext5 = mult;
}


# VPACK2HL      a,b,c   00101bbb001010010BBBCCCCCCAAAAAA
# VPACK2HL      a,b,u6  00101bbb011010010BBBuuuuuuAAAAAA
# VPACK2HL      b,b,s12 00101bbb101010010BBBssssssSSSSSS
# VPACK2HL<.cc> b,b,c   00101bbb111010010BBBCCCCCC0QQQQQ
# VPACK2HL<.cc> b,b,u6  00101bbb111010010BBBuuuuuu1QQQQQ

:VPACK2HL^f32_cc f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_EXT5) & f32_ext_dop_i=0b101001 & f32_bit_F=0b0 & f32_cc & f32_A_B_dst) ... & f32_C_U6_S12_src & f32_B_src {
  build f32_cc;

  f32_A_B_dst = ((f32_B_src & 0x0000FFFF) << 16) | (f32_C_U6_S12_src & 0x0000FFFF);
}







# ***********************************************************************************************
# ***********************************************************************************************
# NEW SECTION FOR F32_APEX 00111
# ***********************************************************************************************
# ***********************************************************************************************
:apex_alu_dop^f32_bit_F f32_gen4_dop_i, f32_A_B_dst, f32_B_src, f32_C_U6_S12_src is (F32_MAJOR_OPCODE=$(F32_APEX) & f32_A_B_dst & f32_bit_F & f32_gen4_dop_i) ... & f32_C_U6_S12_src & f32_B_src {
	
}
